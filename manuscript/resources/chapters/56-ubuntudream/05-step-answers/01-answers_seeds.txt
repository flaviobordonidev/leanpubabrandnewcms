{id: 56-ubuntudream-03-lessons-steps-03-users_answers}
# Cap 3.3 -- Le risposte per ogni utente

In questo capitolo usiamo gli utenti ed il login già sviluppato per elisinfo e creiamo una tabella di risposte in modo che alle varie domande di ogni lezione associamo una risposta differente per ogni utente.
Ogni utente avrà quindi un suo registro degli esercizi svolti e delle risposte date. Anche se per gli esercizi di allenamento contano poco, diventano invece importanti nel percorso coaching.
Più avanti, nel percorso coaching, inseriremo anche un campo boolean per le domande importanti, ossia quelle che utilizzeremo nei giornali di viaggio dell'utente. 

Attenzione:

* NON stiamo parlando di tabella polimorfica. (Vedi 50-elisinfo/04-Companies/06-polymorfic_telephonable)
  quindi niente tabella "userable".
  
* NON stiamo parlando di tabella "ponte" molti-a-molti (Vedi 50-elisinfo/06-company_person_maps/01-company_person_maps_seeds)
  quindi niente tabella "post_user_maps".


Risorse esterne:

* https://thinkster.io/tutorials/angular-rails/associating-users-with-posts-and-comments
* https://www.learneroo.com/modules/145/nodes/782
* https://github-wiki-see.page/m/StanfordBioinformatics/pulsar_lims/wiki/How-to-set-the-current-user-when-building-or-creating-an-association




## Apriamo il branch "Users Answers"

{caption: "terminal", format: bash, line-numbers: false}
```
$ git checkout -b ua
```




## Progettiamo la tabela answers

Siccome ogni utente darà la sua personale risposta dobbiamo creare una tabella answers che avrà una relazione molti-a-uno con steps.
Ogni step c'è una tranche di video e una domanda. A quella domanda ci sono molte risposte; una risposta per ogni utente.

Abbiamo diviso le varie colonne della tabella in principali e secondarie perché non implementeremo tutte le colonne da subito ma iniziamo con le principali e poi aggiungiamo le altre di volta in volta facendo dei migrate di aggiunta ed aggiornando controller, model e views.

Colonne principali:

* content:string           -> (255 caratteri) Le risposte sono brevi, un po' alla twitter, per non perdere la concentrazione sulla visualizzazione.
  (un'alternativa poteva essere: "value:string")


Colonne secondarie:

* nessuna


Tabelle collegate 1-a-molti (chiavi esterne)

* steps:ref
* users:ref


Tabelle collegate molti-a-1 (non ho campi di chiave esterna perché saranno sull'altra tabella)

* nessuna



## Impementiamo la tabella

Creiamo la tabella iniziale con le colonne principali e la colonna della chiave primaria esterna "step_id".
A scopo didattico, la colonna con la chiave esterna "user_id" la inseriamo più avanti.

Quando creiamo una nuova tabella ci conviene SEMPRE usare lo scaffold ed eventualmente eliminare il contrller e le views se non ci servono.

I> ATTENZIONE: con "rails generate scaffold ..." -> usiamo il SINGOLARE
    -> lui in automatico genera correttamente la tabella, il controller e le views al plurale.

{caption: "terminal", format: bash, line-numbers: false}
```
$ rails g scaffold Answer content:string step:references
```

[Si poteva usare anche "g model" perché il controller e le view non le usiamo. Ma è più facile cancellarle che crearle manualmente se vediamo che servino in futuro]

Volendo al posto di *:references* si può usare l'alias *:belongs_to* ma noi preferiamo *:references*. 

Nota: "step:references" crea la chiave esterna step_id, mette l'indice ed imposta la relazione 1-a-molti nei models.

vediamo il migrate generato

{id: "56-05-01_01", caption: ".../db/migrate/xxx_create_answers.rb -- codice 01", format: ruby, line-numbers: true, number-from: 1}
```
class CreateAnswers < ActiveRecord::Migration[6.0]
  def change
    create_table :answers do |t|
      t.string :content
      t.references :step, null: false, foreign_key: true

      t.timestamps
    end
  end
end
```

[tutto il codice](#56-05-01_01all)


Effettuiamo il migrate del database per creare la tabella sul database

{caption: "terminal", format: bash, line-numbers: false}
```
$ sudo service postgresql start
$ rails db:migrate
```

Da Rails 5 il ".references ..., foreign_key: true" aggiunge già le chiavi esterne e l'indice (come si può vedere su .../db/schema.rb dopo il migrate del database).

{id: "56-05-01_02", caption: ".../db/schema.rb -- codice 02", format: ruby, line-numbers: true, number-from: 1}
```
  create_table "answers", force: :cascade do |t|
    t.string "content"
    t.bigint "step_id", null: false
    t.datetime "created_at", precision: 6, null: false
    t.datetime "updated_at", precision: 6, null: false
    t.index ["step_id"], name: "index_answers_on_step_id"
  end
```

[tutto il codice](#56-05-01_02all)




## Completiamo la relazione 1-a-molti nei models

Lato model Answer il *belongs_to :step* lo troviamo già inserito grazie al ":references" usato prima. Quello che inseriamo è la struttura di commenti per organizzare il crescimento del model.

{id: "56-05-01_03", caption: ".../app/models/answer.rb -- codice 03", format: ruby, line-numbers: true, number-from: 11}
```
class Answer < ApplicationRecord
  # == Constants ============================================================
  
  # == Extensions ===========================================================

  # == Attributes ===========================================================

  # == Relationships ========================================================

  ## many-to-one
  belongs_to :step

  # == Validations ==========================================================

  # == Scopes ===============================================================

  # == Callbacks ============================================================

  # == Class Methods ========================================================

  # == Instance Methods =====================================================

end
```

[tutto il codice](#56-05-01_03all)


Lato model Step il *has_many :answers* lo inseriamo noi.
Su # == Relationships nel sottogruppo ## many-to-one

{id: "56-05-01_04", caption: ".../app/models/step.rb -- codice 04", format: ruby, line-numbers: true, number-from: 11}
```
  has_many :answers, dependent: :destroy
  accepts_nested_attributes_for :answers, allow_destroy: true, reject_if: proc{ |attr| attr['content'].blank? }
```

[tutto il codice](#56-05-01_04all)


Analizziamo il codice:

* dependent: :destroy -> questa opzione fa in modo che quando eliminiamo uno step in automatico vengono cancellati anche tutte le sue risposte.
* allow_destroy: true -> permette di cancellare le form annidate
* reject_if: proc{ |attr| attr['number'].blank? } -> evita che vengano salvate form annidate in cui non è stato messo il numero di telefono



## Inseriamo delle risposte da console


{caption: "terminal", format: bash, line-numbers: false}
```
$ rails c

> l1 = Lesson.first
> l1.steps
> l1.steps[0]
> l1.steps[0].answers
> l1.steps[0].answers.new(content: "mattoni").save
> a1 = l1.steps[0].answers.first
> a2 = l1.steps[0].answers.new(content: "cartone")
> a2.save

> l1 = Lesson.first
> step1 = l1.steps.first
> step1.answers.new(content: "vino").save
> step1.answers.new(content: "birra").save
> step1.answers.new(content: "rock and roll").save
> exit

```

Curiosità:
il comando 
> a2 = l1.steps[1].answers.new(content: "cartone").save
avrebbe associato alla variabile a2 il valore True, ossia il risultato del salvataggio.
Non avrebbe associato l'oggetto answers[2].





## Implementiamo sulle views

Sulla pagina views/steps/show cambio il form di edit dello step con un nuovo form che invece va in new della answer.
Ossia ogni step presento sempre UNA NUOVA RISPOSTA. 

Iniziamo mostrando le risposte caricate da console.

{id: "56-05-01_05", caption: ".../views/steps/show.html.erb -- codice 5", format: HTML+Mako, line-numbers: true, number-from: 1}
```
<p>
  <strong>Answers</strong>
  <ul>
    <% @step.answers.each do |answer| %>
      <li>
        <%= answer.content %>
      </li>
    <% end %>
  </ul>
</p>
```

[tutto il codice](#56-05-01_05all)


Adesso impostiamo il form per inserire una nuova risposta.
Per questo mi appoggio ad answers_controller.




## Aggiorniamo il controller

Permettiamo che siano passati i parametri relativi alle risposte (answers).
Per farlo aggiungiamo "answers_attributes[]" al "params.require(:step).permit". Questo lo possiamo fare perché abbiamo inserito nel model Step la voce "accepts_nested_attributes_for :answers". 

{id: "56-05-01_06", caption: ".../app/controllers/steps_controller.rb -- codice 06", format: ruby, line-numbers: true, number-from: 70}
```
    # Never trust parameters from the scary internet, only allow the white list through.
    def step_params
      params.require(:step).permit(:question, :answer, :lesson_id, answers_attributes: [:_destroy, :id, :content])
    end
```

[tutto il codice](#56-05-01_06all)

Lato server / back-end abbiamo terminato.



## Aggiorniamo la view

All'interno del form_with che interagisce con il controller steps_controller, che nel nostro caso ha una route annidata a lessons, inseriamo un form annidato attraverso il codice "form.fields_for".
Il form annidato è quello che aggiorna la parte answers, sfruttando le impostazioni fatte precedentemente sul controller e il model di Step.

{id: "56-05-01_07", caption: ".../views/steps/show.html.erb -- codice 7", format: HTML+Mako, line-numbers: true, number-from: 1}
```
<%= form_with(model: [@lesson, @step], local: true) do |form| %>
  <!-- Creiamo nuovo Record -->
  <%= form.fields_for :answers, Answer.new do |answer| %>
    <%= render "answer_fields", form: answer %>
  <% end %>
  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>

```

[tutto il codice](#56-05-01_07all)


Ogni volta che facciamo submit del form aggiungiamo una nuova risposta.


