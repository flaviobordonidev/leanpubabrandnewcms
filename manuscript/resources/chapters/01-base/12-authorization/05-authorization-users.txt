# Implementiamo le autorizzazioni per users

Autentichiamo ed Autorizziamo in funzione del ruolo

Finalmente cominciamo ad attivare la sicurezza ed iniziamo definendo le autorizzazioni per la gestione degli utenti; tabella users.


Risorse web
* [Devise authentication 48:50](https://www.youtube.com/watch?v=qruGD_8ry7k
* [current_user present? and signed_in](https://stackoverflow.com/questions/45398702/what-is-the-difference-between-current-user-present-and-if-user-signed-in)
* [Differenza fra public e private](https://www.codementor.io/anuraag.jpr/the-difference-between-public-private-and-protected-methods-in-ruby-6zsvkeeqr)
* [Rails Authorization With Pundit - parte da zero ed installa anche devise ed usa anche spec tests](https://www.youtube.com/watch?v=qruGD_8ry7k)




## Apriamo il branch "Authorization Users"

{title="terminal", lang=bash, line-numbers=off}
```
$ git checkout -b au
```




## Aggiungiamo policy per User

Per aggiungere una policy per un modello specifico aggiungiamo il nome del model.

{title="terminal", lang=bash, line-numbers=off}
```
$ rails g pundit:policy User


ec2-user:~/environment/myapp (au) $ rails g pundit:policy User
Running via Spring preloader in process 3973
      create  app/policies/user_policy.rb
      invoke  test_unit
      create    test/policies/user_policy_test.rb
```

questo ci crea la seguente policy

{title=".../app/policies/user_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
```
class UserPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
```


I> Se ci si fosse loggati come IAM user e non si fossero gestite bene le autorizzazioni potrebbe essere necessario lanciare lo script come root. Si dovrà successivamente rivedere le autorizzazioni dei files creati o ricopiare il codice su nuovi files. Se il file è stato creato lanciando lo script come root per poter modificare i files crearne uno nuovo, copiarci tutto il codice ed eliminare il vecchio.

{title="terminal", lang=bash, line-numbers=off}
```
$ sudo su
# rails g pundit:policy User

cloud9:~/environment/rigenerabatterie (au) $ sudo su
[root@ip-172-31-7-7 rigenerabatterie]# rails g pundit:policy User
Running via Spring preloader in process 574
      create  app/policies/user_policy.rb
      invoke  test_unit
      create    test/policies/user_policy_test.rb
[root@ip-172-31-7-7 rigenerabatterie]# exit
exit
```




## Aggiungiamo ruolo di amministratore al primo utente da console

Al momento qualsiasi utente che fa login può impostare il ruolo di admin da interfaccia grafica (GUI).
Però noi lo impostiamo da console perché a breve limiteremo la GUI.

Usando "enum" associamo il ruolo "admin" al primo utente

{title="terminal", lang=bash, line-numbers=off}
```
$ sudo service postgresql start
$ rails c
-> User.first.update(role: :admin)


2.4.1 :001 > User.first.update(role: :admin)
  User Load (1.4ms)  SELECT  "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT $1  [["LIMIT", 1]]
   (0.1ms)  BEGIN
   (0.1ms)  COMMIT
 => true 
```

Avremmo potuto anche usare ** User.first.admin! **




## Implementiamo policy che autorizza la creazione di un nuovo post solo all'ammministratore

{id="01-09-05_01", title=".../app/policies/user_policy.rb", lang=ruby, line-numbers=on, starting-line-number=3}
```
  def create?
    @user.admin?
  end
```

[Codice 01](#01-09-05_01all)

Questo codice indica a pundit di vedere se siamo nell'azione create del controller e la autorizza solo se l'utente è "admin". 
Infatti @user.admin? è TRUE se l'utente ha il ruolo di amministratore. Altrimenti @user.admin? è FALSE e pundit non autorizza l'esecuzione.

Non dobbiamo implementare anche la poilcy **new?** perché su **application_policy** viene impostato di default che **new?** prende le stesse autorizzazioni di **create?**.
Come possiamo vedere nella seguente chiamata:

{title=".../app/policies/application_policy.rb", lang=ruby, line-numbers=on, starting-line-number=21}
```
  def new?
    create?
  end
```




## Implementiamo nel controller

Adesso che la policy di autorizzazione è pronta possiamo indicare all'azione "create" del controller "user" di passare per l'autorizzazione

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=19}
```
  def new
    @user = User.new
    authorize @user
```

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=19}
```
  def create
    @user = User.new(user_params)
    authorize @user
```




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
```
$ sudo service postgresql start
$ rails s
```

* https://mycloud9path.amazonaws.com/login

Se ci logghiamo con il secondo utente (Bob) che non ha i diritti di amministratore, quando proviamo a creare un nuovo utente riceviamo l'errore: "Pundit::NotAuthorizedError in UsersController#new".
Se ci logghiamo con il primo utente (Ann) che ha i diritti di amministratore, possiamo creare un nuovo utente senza nessun errore.




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
```
$ git add -A
$ git commit -m "add pundit authorization on actions new and create of users"
```




## Rimuoviamo la protezione di Devise

Togliamo la protezione di Devise per le views "users" così rinforziamo il nostro scope di pundit (la nostra autorizzazione) includendo anche il caso di un utente non autenticato (non loggato).

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
```
  #before_action :authenticate_user!
```

Adesso possiamo arrivare a users/index anche senza essere loggati. Se proviamo a creare un nuovo utente riceviamo un errore ma non è un errore di autorizzazione di pundit. E' un errore nel codice dell'applicazione. Risolviamo questo rinforziamo la protezione di pundit.


{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=19}
```
  def create?
    if @user.present?
      @user.admin?
    else
      false
    end
  end
```

Adesso se si prova a creare un nuovo utente senza essere loggati si riceve un errore di autorizzazione.




## Completiamo implementando le policies per tutte le azioni rest-full di users

Autorizziamo l'index visibile a tutti mentre tutte le altre azioni le può eseguire solo l'amministratore. Inoltre mettiamo un controllo per vedere se è presente un utente loggato. Nel caso in cui nessuno ha fatto login permettere solo la visualizzazione dell'index e vietare tutto il resto.
Unica eccezione è l'azione show che può essere eseguita:

* sia dall'amministratore per tutti i record della tabella users
* sia da qualsiasi utente loggato ma SOLO per il suo record della tabella users

{id="01-09-05_02", title=".../app/policies/user_policy.rb", lang=ruby, line-numbers=on, starting-line-number=2}
```
  def index?
    true
  end

  def show?
    #@user.present? ? @user.admin? : false
    if @user.present?
      @user.admin? or @user == @record
    else
      false
    end
  end
  
  def create?
    if @user.present?
      @user.admin?
    else
      false
    end
  end
  
  def update?
    if @user.present?
      @user.admin?
    else
      false
    end
  end

  def destroy?
    if @user.present?
      @user.admin?
    else
      false
    end
  end
```

[Codice 02](#01-09-05_02all)

La linea di codice "@user == @record" verifica se l'utente loggato è lo stesso del record a cui si vuole accedere.

Questo perché nelle policies di pundit abbiamo che:

* la variabile @user rappresenta l'utente loggato
* la variabile @record rappresenta l'utente nel database

Questo può confondere perché normalmente nell'applicazione Rails per riferirci all'utente loggato usiamo il metodo "current_user" e per riferirci all'utente nel database usiamo la variabile "@user".

La variabile "@record" è definita sulla classe ApplicationPolicy da cui la ereditiamo.




## Implementiamo nel controller

Adesso che la policy di autorizzazione è pronta possiamo indicare all'azione "index" del controller "users" di passare per l'autorizzazione

{id="01-09-05_03", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=9}
```
  def index
    @users = User.all
    authorize @users
```

Per le azioni [:show, :edit, :update, :destroy], che chiamano la funzione "set_user" con il before_action, inserisco l'autorizzazione direttamente sulla funzione "set_user"

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=81}
```
    def set_user
      @user = User.find(params[:id])
      authorize @user
```

[Codice 03](#01-09-05_03all)




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
```
$ sudo service postgresql start
$ rails s
```

* https://mycloud9path.amazonaws.com/users

Se non siamo loggati come amministratori, tentando "editare" "creare nuovo" o "eliminare" un utente, riceveremo l'errore di azione non autorizzata: "Pundit::NotAuthorizedError".




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
```
$ git add -A
$ git commit -m "add pundit authorization on all actions of users"
```




## Messaggio di non autorizzato invece dell'errore

In fase di sviluppo l'errore Pundit::NotAuthorizedError è gestibile ma in fase di produzione no. Riceveremmo solo una pagina bianca con "Ops! c'è stato un errore".
E' quindi opportuno gestire l'errore reindirizzando sulla pagina che ha provato l'azione non autorizzata e visualizzando un messaggio di "non autorizzato".

Per farlo aggiungiamo il seguente codice ad ApplicationController.

{id="01-09-05_04", title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=4}
```
  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized
```
 
{title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=17}
```
  private

    def user_not_authorized
      redirect_to request.referrer || root_path, notice: "You are not authorized to perform this action."
    end
```

[Codice 04](#01-09-05_04all)


I> il codice "protected" è prima del codice "private" perché è meno restrittivo.
I>
I> Dal più accessibile al più restrittivo abbiamo: "public" -> "protected" -> "private"




## verifichiamo

{title="terminal", lang=bash, line-numbers=off}
```
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
```

Se non siamo loggati come amministratori,tentando violare le autorizzazioni impostate, riceveremo il messaggio "Non sei autorizzato ad eseguire questa azione".




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
```
$ git add -A
$ git commit -m "Rescue from Pundit::NotAuthorizedError"
```




## Rimettiamo la protezione di Devise 

Rimettiamo la protezione di Devise per le views "users".

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
```
  before_action :authenticate_user!
```




## Implementiamo l'autorizzazione per il cambio di ruolo

Solo admin deve poter cambiare il ruolo!
Lo so che tutta l'azione edit è già autorizzata da pundit ma aggiungiamo questa nel caso in cui volessimo permettere modifiche solo al proprio record dell'utente loggato, come facciamo per show.
Non sarà comunque il nostro caso perché le eventuali modifiche dell'utente loggato le faremmo fare a "registerable" di devise, però una sicurezza in più non guasta ^_^.

Per questa autorizzazione non ci serve scomodare pundit. Scomodiamo solo l'helper di Devise.

Inseriamo un controllo nel selettore che permettere di cambiare ruolo e lo visualizziamo solo se siamo amministratori

{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
```
  <%# if user_signed_in? and current_user.admin? %>
  <% if current_user.present? and current_user.admin? %>
    <div class="field">    
      <%= form.label :role %>
      <%#= form.text_field :role %>
      <%= form.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
    </div>
  <% end %>
```

Se ti stai domandando qual'è la differenza fra user_signed_in? e current_user.present? la risposta è "non c'è nessuna differenza". 

Adesso solo se l'utente è amministratore può cambiare i ruoli.




## Evitiamo che l'utente loggato come amministratore cambi il suo ruolo

Evitiamo di tagliarci il ramo su cui siamo seduti ^_^.

{title=".../app/views/users/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
```
  <% if current_user.present? and current_user.admin? and @user != current_user %>
    <div class="field">    
      <%= form.label :role %>
      <%= form.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
      <%#= form.number_field :role %>
    </div>
  <% end %>
```

Ti ricordo che "!=" è l'opposto di "==". 
Ad esempio le due condizioni seguenti sono identiche:

* unless user == current_user
* if user != current_user




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
```
$ git add -A
$ git commit -m "Protect views/users/edit"
```




## Publichiamo su heroku

{title="terminal", lang=bash, line-numbers=off}
```
$ git push heroku au:master
$ heroku run rails db:migrate
```

rendiamo amministratore anche il primo utente nel database di heroku

{title="terminal", lang=bash, line-numbers=off}
```
$ heroku run rails c
-> User.first.admin!
```




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
```
$ git checkout master
$ git merge au
$ git branch -d au
```




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
```
$ git push origin master
```




## Il codice del capitolo




[Codice 01](#01-09-05_01)

{id="01-09-05_01all", title=".../app/policies/user_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
```
class UserPolicy < ApplicationPolicy
  
  def create?
    @user.admin?
  end
  
  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
```




[Codice 02](#01-09-05_02)

{id="01-09-05_02all", title=".../app/policies/user_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
```
class UserPolicy < ApplicationPolicy

  def index?
    true
  end

  def show?
    #@user.present? ? @user.admin? : false
    if @user.present?
      @user.admin? or @user == @record
    else
      false
    end
  end
  
  def create?
    if @user.present?
      @user.admin?
    else
      false
    end
  end
  
  def update?
    if @user.present?
      @user.admin?
    else
      false
    end
  end

  def destroy?
    if @user.present?
      @user.admin?
    else
      false
    end
  end

  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
```




[Codice 03](#01-09-05_03)

{id="01-09-05_03all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
```
class UsersController < ApplicationController
  before_action :authenticate_user!
  before_action :set_user, only: [:show, :edit, :update, :destroy]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
    authorize @users
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  # GET /users/new
  def new
    @user = User.new
    authorize @user
  end
  
  # GET /users/1/edit
  def edit
  end

  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)
    authorize @user

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    if params[:user][:password].blank?
      params[:user].delete(:password)
      params[:user].delete(:password_confirmation)
    end
    current_user_temp = current_user
    respond_to do |format|
      if @user.update(user_params)
        format.html do
          # Logghiamoci di nuovo automaticamente bypassando le validazioni
          sign_in(@user, bypass: true) if @user == current_user_temp
          redirect_to @user, notice: 'User was successfully updated.'
        end
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy unless @user == current_user
    respond_to do |format|
      format.html do 
        redirect_to users_url, notice: 'User was successfully destroyed.' unless @user == current_user
        redirect_to users_url, notice: 'Non posso eliminare utente loggato.' if @user == current_user
      end
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
      authorize @user
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at, :role)
    end

end
```




[Codice 04](#01-09-05_04)

{id="01-09-05_04all", title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
```
class ApplicationController < ActionController::Base
  include Pundit

  before_action :configure_permitted_parameters, if: :devise_controller?

  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized

  def after_sign_in_path_for(resource_or_scope)
    users_path
    #current_user
  end

  protected
  
    def configure_permitted_parameters
      devise_parameter_sanitizer.permit(:sign_in, keys: [:role])
      devise_parameter_sanitizer.permit(:sign_up, keys: [:role])
      devise_parameter_sanitizer.permit(:account_update, keys: [:role])
    end

  private

    def user_not_authorized
      redirect_to request.referrer || root_path, notice: "You are not authorized to perform this action."
    end
end
```
