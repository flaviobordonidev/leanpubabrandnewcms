{id: 01-base-04-heroku-02-inizializiamo_heroku}
# Cap 4.2 -- Andiamo in produzione su Heroku

Pubblichiamo la nostra applicazionie sull'ambiente di produzione Heroku.

Andiamo subito in produzione così risolviamo di volta in volta gli eventuali problemi che si presentano senza essere costretti a fare un troubleshooting su tutto l'applicativo.

Risorse interne:

* 99-rails_references/Heroku/




## Apriamo il branch "Pubblichiamo in Produzione"

{caption: "terminal", format: bash, line-numbers: false}
```
$ git checkout -b pp
```




## Verifichiamo se abbiamo Heroku installato su aws Cloud9  

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku --version


user_fb:~/environment/bl6_0 (master) $ heroku --version
Command 'heroku' not found, but can be installed with:
sudo snap install heroku
```

Nel nostro caso non è installato.





## Creiamoci un account Heroku  

Per prima cosa creiamoci un account su www.heroku.com

![fig. 01](chapters/01-base/04-heroku/02_fig01-heroku_signup.png)




## Installiamo Heroku CLI


Come abbiamo già fatto per PostgreSQL, anche Heroku lo installiamo sulla cartella principale di aws Cloud9: "/environment".
Assicuriamoci di essere sulla cartella principale

{caption: "terminal", format: bash, line-numbers: false}
```
$ cd ~/environment
```

Per installare Heroku dobbiamo scaricare ed installare la "heroku CLI" (ex heroku-toolbelt).
Seguendo le indicazioni di [Heroku](https://devcenter.heroku.com/articles/heroku-cli) il comando che dobbiamo usare da aws cloud9, che è un "docker container" è questo:

{caption: "terminal", format: bash, line-numbers: false}
```
$ sudo su - 
-> curl https://cli-assets.heroku.com/install.sh | sh
-> exit


ec2-user:~/environment $ sudo su -
Last failed login: Thu Jan  3 14:52:40 UTC 2019 on pts/1
There was 1 failed login attempt since the last successful login.
[root@ip-172-31-34-226 ~]# curl https://cli-assets.heroku.com/install.sh | sh
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1892  100  1892    0     0   6662      0 --:--:-- --:--:-- --:--:--  6685
Installing CLI from https://cli-assets.heroku.com/heroku-linux-x64.tar.xz
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100 15.3M  100 15.3M    0     0  6617k      0  0:00:02  0:00:02 --:--:-- 6618k
v11.3.0
heroku installed to /usr/local/bin/heroku
heroku/7.19.4 linux-x64 node-v11.3.0
[root@ip-172-31-34-226 ~]# exit
logout
ec2-user:~/environment $ 
```


Verifichiamo che l'installazione è andata a buon fine.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku --version


ec2-user:~/environment $ heroku --version
heroku/7.19.4 linux-x64 node-v11.3.0
```




### Alternativa tramite stringa Michael Hartl

Un'alternativa è eseguire la stringa di comando preparata da Michael Hartl del railstutorial.

{caption: "terminal", format: bash, line-numbers: false}
```
$ source <(curl -sL https://cdn.learnenough.com/heroku_install)
```

Questo comando esegue uno script fatto da Michael che esegue i seguenti passi:
* Scarica il pacchetto per linux dal sito di heroku (https://cli-assets.heroku.com/heroku-linux-x64.tar.gz) tramite curl. 
* Scompatta e rimuove il pacchetto.
* Sposta i files scompattati su /usr/local. 
* Poi attiva il puntamento su $HOME/.profile per permettere di eseguire il comando "heroku" da qualsiasi path ci troviamo.  

Ne possiamo vedere il contenuto qui:

[cod. b](beginning-heroku-02b-learnenogh-heroku_install)

I> Questa alternativa funziona ma tutte le volte che riapro l'istanza di cloud9 sono costretto a rilanciare il comando altrimenti non mi riconosce il comando "heroku ..."

proviamo a lanciarla come super user

{caption: "terminal", format: bash, line-numbers: false}
```
$ sudo -s
$ source <(curl -sL https://cdn.learnenough.com/heroku_install)
$ exit
```




## Alternativa tramite npm

Visualizza la versione di nvm

{caption: "terminal", format: bash, line-numbers: false}
```
$ nvm

$ nvm ls

$ nvm ls-remote
```

Update npm

{caption: "terminal", format: bash, line-numbers: false}
```
$ nvm i v8         # Any version > 8 will do e.g. nvm i v9 
```

Install heroku cli

{caption: "terminal", format: bash, line-numbers: false}
```
$ npm install -g heroku

$ npm install -g npm
```

Done!

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku --version

heroku/7.0.15 linux-x64 node-v8.11.1
```




## Creiamo l'app su heroku

Torniamo nella cartella della nostra applicazione Rails

{caption: "terminal", format: bash, line-numbers: false}
```
$ cd myapp
```


Loghiamoci con le credenziali usate nella creazione dell'account heroku (sign_up).

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku login

ec2-user:~/environment/myapp (master) $ heroku login
heroku: Press any key to open up the browser to login or q to exit: 
 ›   Warning: Cannot open browser. Go to https://cli-auth.heroku.com/auth/browser/05cbd1ba-41b2-45c6-8258-8977aadca96c to finish login or run heroku 
 ›   login --interactive
 ›
Logging in... done
```

Questa procedura ti fa fare il login sulla pagina web. Basta cliccare sul link, scegliere "open" ed eseguire il login.

![fig. 02](images/01-beginning/04-heroku/02_02-heroku-login-via_aws_cloud9.PNG)


Aggiungiamo la nostra chiave di criptatura in modo da stabilire un canale sicuro tra aws Cloud9 ed Heroku.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku keys:add


ec2-user:~/environment/myapp (master) $ heroku keys:add
Could not find an existing SSH key at ~/.ssh/id_rsa.pub
? Would you like to generate a new one? Yes
Generating public/private rsa key pair.
Your identification has been saved in /home/ec2-user/.ssh/id_rsa.
Your public key has been saved in /home/ec2-user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:SP7SsNopsq4k+nhqb7VJO/E3/ShOvX1G5/Po+9EIYHs ec2-user@ip-172-31-34-226
The key's randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|      .   o      |
|     o . . o     |
|      + S . E    |
|     + =  .. . oo|
|..  o O o...  ooo|
|+oo..B +.+ .+  =o|
|***+..+ o.oo.+*o=|
+----[SHA256]-----+
Uploading /home/ec2-user/.ssh/id_rsa.pub SSH key... done
ec2-user:~/environment/myapp (master) $ 
```


Creiamo una nuova app su heroku.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku create


cloud9:~/environment/rigenerabatterie (pubprod) $ heroku create
Creating app... done, ⬢ pacific-sea-70617
https://pacific-sea-70617.herokuapp.com/ | https://git.heroku.com/pacific-sea-70617.git
```

l'app viene creata dinamnicamente. In questo caso è stato creato "pacific-sea-70617" ma può essere qualsiasi nome.


Per verficarlo si può usare il comando

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku domains

cloud9:~/environment/rigenerabatterie (pubprod) $ heroku domains
=== pacific-sea-70617 Heroku Domain
pacific-sea-70617.herokuapp.com
```

o

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku apps:info

cloud9:~/environment/rigenerabatterie (pubprod) $ heroku apps:info
=== pacific-sea-70617
Auto Cert Mgmt: false
Dynos:          
Git URL:        https://git.heroku.com/pacific-sea-70617.git
Owner:          flavio.bordoni.dev@gmail.com
Region:         us
Repo Size:      0 B
Slug Size:      0 B
Stack:          heroku-18
Web URL:        https://pacific-sea-70617.herokuapp.com/
```


Possiamo verificare che abbiamo la configurazione git corretta con

{caption: "terminal", format: bash, line-numbers: false}
```
$ git config --list | grep heroku

cloud9:~/environment/rigenerabatterie (pubprod) $ git config --list | grep heroku
remote.heroku.url=https://git.heroku.com/pacific-sea-70617.git
remote.heroku.fetch=+refs/heads/*:refs/remotes/heroku/*
```

Se vedi "fatal: not in a git directory" allora probabilmente non sei nella directory corretta. Altrimenti puoi mandare in produzione il tuo codice.




## Rinominiamo l'app

Diamo all'app di heroku un nome simile a quello della nostra istanza di aws cloud9 (myapp_1) così è più facile associarli.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku rename myapp-1-blabla

ec2-user:~/environment/myapp (master) $ heroku rename myapp-1-blabla
Renaming quiet-waters-28223 to myapp-1-blabla... done
https://myapp-1-blabla.herokuapp.com/ | https://git.heroku.com/myapp-1-blabla.git
Git remote heroku updated
 ▸    Don't forget to update git remotes for all other local checkouts of the app.
```

Attenzione:
Il nome deve essere unico in tutto l'ambiente Heroku. Nel nostro caso ho aggiunto "-blabla" per renderlo unico.

verifichiamo di nuovo le informazione della nostra app

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku apps:info


ec2-user:~/environment/myapp (master) $ heroku apps:info
=== myapp-1-blabla
Auto Cert Mgmt: false
Dynos:          
Git URL:        https://git.heroku.com/myapp-1-blabla.git
Owner:          flavio.bordoni.dev@gmail.com
Region:         us
Repo Size:      0 B
Slug Size:      0 B
Stack:          heroku-18
Web URL:        https://myapp-1-blabla.herokuapp.com/
```

e la configurazione di git

{caption: "terminal", format: bash, line-numbers: false}
```
$ git config --list | grep heroku

ec2-user:~/environment/myapp (master) $ git config --list | grep heroku
remote.heroku.url=https://git.heroku.com/myapp-1-blabla.git
remote.heroku.fetch=+refs/heads/*:refs/remotes/heroku/*
```

Adesso è tutto pronto. Posso fare il commit finale in locale e uploadare tutto in remoto.

{caption: "terminal", format: bash, line-numbers: false}
```
$ git add -A
$ git commit -m "ready to public in production on heroku"
```




## Pubblichiamo su heroku

Attenzione! per pubblicare su heroku da un branch si usa un comando specifico ( git push heroku yourbranch:master )
(vedi https://devcenter.heroku.com/articles/git)

{caption: "terminal", format: bash, line-numbers: false}
```
$ git push heroku pp:master
```



### Verifichiamo production

La nostra applicazione è ora in produzione su heroku. La possiamo vedere sul broser all'URL

https://myapp-1-blabla.herokuapp.com/

I> siccome non abbiamo ancora tabelle di database è stato sufficiente fare il "git push" ma quando avremo tabelle di database dobbiamo ricordarci di eseguire il "migrate" anche su heroku.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku run rake db:migrate
```




## Impostiamo i dynos

Per visualizzare la nostra app sul web stiamo usando un dyno di tipo web.
Vediamo quanti dynos abbiamo associato alla nostra app in produzione su heroku 

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku ps


ec2-user:~/environment/myapp (master) $ heroku ps
Free dyno hours quota remaining this month: 985h 11m (98%)
Free dyno usage for this app: 0h 0m (0%)
For more information on dyno sleeping and how to upgrade, see:
https://devcenter.heroku.com/articles/dyno-sleeping

=== web (Free): bin/rails server -p $PORT -e $RAILS_ENV (1)
web.1: up 2019/01/03 15:15:56 +0000 (~ 5m ago)
```

abbiamo 1 dyno attivo **web.1: up**

Se vogliamo assegnare più dynos usiamo il comando **ps:scale**. Ad esempio assicuriamoci di avere 1 dyno attivo per il web.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku ps:scale web=1


ec2-user:~/environment/myapp (master) $ heroku ps:scale web=1
Scaling dynos... done, now running web at 1:Free
{caption: "terminal", format: bash, line-numbers: false}
```

Possiamo verificare che non è cambiato nulla perché era già attivo di default 1 dyno.

{caption: "terminal", format: bash, line-numbers: false}
```
$ heroku ps


ec2-user:~/environment/myapp (master) $ heroku ps
Free dyno hours quota remaining this month: 985h 11m (98%)
Free dyno usage for this app: 0h 0m (0%)
For more information on dyno sleeping and how to upgrade, see:
https://devcenter.heroku.com/articles/dyno-sleeping

=== web (Free): bin/rails server -p $PORT -e $RAILS_ENV (1)
web.1: up 2019/01/03 15:15:56 +0000 (~ 5m ago)
```




## Chiudiamo il branch

Lo chiudiamo nel prossimo capitolo
