# Tabelle di esempio

Abbiamo già creato la tabella **users** inizializzando **devise** adesso creiamo la tabelle di esempio **eg_posts** che ci ci aiuterà a verificare le future implementazioni che faremo nei prossimi capitoli.

In inglese e.g. è l'abbriviazione di "for example" dal latino (exempli gratia). Queste sono "Pagine Dinamiche di Esempio".




## Apriamo il branch "Examples Posts"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b ep
~~~~~~~~




## Impementiamo tabella eg_posts

implementiamo tutta la gestione degli articoli come esempio inclusa la tabella eg_posts per gestire gli articoli creati da utenti con ruolo di autore.
Generiamo tutto lo **scaffold** perché vogliamo anche i controllers e le views. 
 - il **migrate** crea la sola tabella
 - il **model** oltre alla tabella crea il model per il collegamento uno-a-molti.
 - lo **scaffold** crea anche il controller e le views.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold EgPost title:string incipit:text user:references
~~~~~~~~

La cosa bella di **user:references** è che, oltre a creare un migration "ottimizzato" per la relazione uno a molti, ci predispone parte della relazione uno-a-molti anche lato model.

vediamo il migrate creato

{title=".../db/migrate/xxx_create_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreateExamplePosts < ActiveRecord::Migration[5.2]
  def change
    create_table :eg_posts do |t|
      t.string :title
      t.text :incipit
      t.references :user, foreign_key: true

      t.timestamps
    end
  end
end
~~~~~~~~

la **t.references :user, foreign_key: true** crea un campo "t.integer :user_id" ed attiva il legame uno a molti lato database.


eseguiamo il migrate 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




### Completiamo la relazione uno-a-molti

verifichiamo example_post, il lato "molti" 

{id="01-08-01_01", title=".../app/models/eg_post.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  belongs_to :user
~~~~~~~~

[Codice 01](#01-08-01_01all)

completiamo user, il lato "uno"

{id="01-08-01_02", title=".../app/models/user.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  has_many :eg_posts
~~~~~~~~

[Codice 01](#01-08-01_02all)




### Inseriamo qualche articolo da console

Inseriamo qualche articolo da terminale nel database locale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
-> u1 = User.find(1)
-> u1.eg_posts.create(title: "Il mio primo articolo", incipit: "Perché scrivere questo articolo")
-> u1.eg_posts.create(title: "Il mio secondo articolo", incipit: "Ci ho preso gusto")
-> u1.eg_posts.create(title: "Il mio terzo articolo", incipit: "Adesso sono esperto")

-> u2 = User.find(2)
-> u2.eg_posts.create(title: "La conferenza uno", incipit: "Una interessante conferenza sul cielo")
-> u2.eg_posts.create(title: "La conferenza due", incipit: "Perché si formano le nuvole? Capiamo il ciclo dell'acqua")
-> u2.eg_posts.create(title: "La conferenza tre", incipit: "Il sole è una stella nana")


-> u3 = User.find(3)
-> u3.eg_posts.create(title: "Studio di caso alfa", incipit: "In questo studio la nostra azienda è stata brava")
-> u3.eg_posts.create(title: "Studio di caso beta", incipit: "In questo studio identifichiamo i pesci nell'acquario")
-> u3.eg_posts.create(title: "Studio di caso gamma", incipit: "Questo studio è praticamente identico a quello dell'architetto")

-> exit
~~~~~~~~


Un altro modo più geek per inserire gli articoli è usando il seguente codice


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
-> u1 = User.where(email: "ann@test.abc").first
-> u2 = User.where(email: "bob@test.abc").first
-> u3 = User.where(email: "carl@test.abc").first
-> 3.times do |i|
-> u1.eg_posts.create title: "articolo di #{u1.email} - articolo numero #{i}"
-> u2.eg_posts.create title: "articolo di #{u2.email} - articolo numero #{i}"
-> u3.eg_posts.create title: "articolo di #{u3.email} - articolo numero #{i}"
-> end

2.4.1 :001 > u = User.where(email: "ann@test.abc")
  User Load (0.3ms)  SELECT  "users".* FROM "users" WHERE "users"."email" = $1 LIMIT $2  [["email", "ann@test.abc"], ["LIMIT", 11]]
 => #<ActiveRecord::Relation [#<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2019-01-04 11:53:46", updated_at: "2019-01-08 11:43:42", role: "admin">]> 
2.4.1 :002 > u = u.first
  User Load (0.3ms)  SELECT  "users".* FROM "users" WHERE "users"."email" = $1 ORDER BY "users"."id" ASC LIMIT $2  [["email", "ann@test.abc"], ["LIMIT", 1]]
 => #<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2019-01-04 11:53:46", updated_at: "2019-01-08 11:43:42", role: "admin"> 
2.4.1 :003 > 50.times do
2.4.1 :004 >     u.posts.create title: "articolo di test"
2.4.1 :005?>   end
   (0.1ms)  BEGIN
  Post Exists (0.5ms)  SELECT  1 AS one FROM "posts" WHERE "posts"."id" IS NOT NULL AND "posts"."slug" = $1 LIMIT $2  [["slug", "articolo-di-test"], ["LIMIT", 1]]
  Post Create (9.6ms)  INSERT INTO "posts" ("title", "user_id", "created_at", "updated_at", "slug") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["title", "articolo di test"], ["user_id", 1], ["created_at", "2019-01-31 13:41:12.110627"], ["updated_at", "2019-01-31 13:41:12.110627"], ["slug", "articolo-di-test"]]
   (1.1ms)  COMMIT

  ...

   (0.1ms)  BEGIN
  Post Exists (0.2ms)  SELECT  1 AS one FROM "posts" WHERE "posts"."id" IS NOT NULL AND "posts"."slug" = $1 LIMIT $2  [["slug", "articolo-di-test"], ["LIMIT", 1]]
  Post Create (0.3ms)  INSERT INTO "posts" ("title", "user_id", "created_at", "updated_at", "slug") VALUES ($1, $2, $3, $4, $5) RETURNING "id"  [["title", "articolo di test"], ["user_id", 1], ["created_at", "2019-01-31 13:41:12.319967"], ["updated_at", "2019-01-31 13:41:12.319967"], ["slug", "articolo-di-test-8fded178-c7b3-4773-b903-fff189c98eba"]]
   (0.7ms)  COMMIT
 => 7
~~~~~~~~

il metodo ".create" è equivalente a ".new" seguito da ".save". E' solo un modo più succinto. Ad esempio le seguenti due linee di codice sono equivalenti:

* Post.create title: "articolo di test"
* Post.new(title: "articolo di test").save


I> Didattica:

~~~~~~~~
5.times { puts "i" }

i
i
i
i
i
~~~~~~~~

~~~~~~~~
5.times do 
  puts "i"
end

i
i
i
i
i
~~~~~~~~

~~~~~~~~
5.times { |i| puts i }

0
1
2
3
4
~~~~~~~~

~~~~~~~~
5.times do |i| 
  puts i
end

0
1
2
3
4
~~~~~~~~




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add table eg_posts"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku ep:master
$ heroku run rails db:migrate
~~~~~~~~

per popolare il database di heroku 


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rails c
~~~~~~~~

e rifare i passi fatti precedentemente per il database locale




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge ep
$ git branch -d ep
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~




## Il codice del capitolo




[Codice 01](#01-08-01_01)

{id="01-08-01_01all", title=".../app/models/example_post.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ExamplePost < ApplicationRecord
  belongs_to :user
end
~~~~~~~~




[Codice 01](#01-08-01_02)

{id="01-08-01_02all", title=".../app/models/user.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class User < ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :registerable, :timeoutable, :trackable and :omniauthable
  devise :database_authenticatable,
         :recoverable, :rememberable, :validatable

  has_many :eg_posts
end
~~~~~~~~
