# Roles

Spieghiamo come assegnare i vari ruoli e quando è utile rolify. 
Iniziamo col dire che la maggior parte delle applicazioni non ha un livello di sofisticazione per cui è richiesto rolify.
In un capitolo più avanti vedremo come usare rolify negli esempi pratici che implementiamo in questi primi capitoli.

Esistono tre forme principali per determinare dei ruoli:

* admin
* enum
* rolify

Le vedremo in dettaglio più avanti in questo capitolo.




## new branch

non serve perché questo capitolo è solo una panoramica




## Pundit

Abbiamo visto come Devise permette di autenticare un utente facendogli fare login. Inoltre Devise si sovrappone un poco a Pundit perché ha una sorta di autorizzazione a livello di view.
Possiamo infatti indicare quali sono le pagine che per essere viste hanno bisogno che un utente sia autenticato (abbia fatto login).

Quindi possiamo dire che Devise ha una sorta di autorizzazione a livello di view.
Similmente possiamo dire che Pundit ha una autorizzazione a livello di tabelle.

Ogni file di policy (set di regole di autorizzazione) ha un corrispettivo file model ed è quindi legato alla tabella del database.
Con pundit autorizziamo le azioni da fare sul database. Nell'esempio qui in basso abbiamo un'idea:

s : show
n : new/create
e : edit/update
d : destroy

       tabelle: | users   | posts     | companies | products | offers | invoices |
----------------------------------------------------------------------------------
admin           | s,n,e,d | s,-,e,d   |
moderator       | -,-,-,- | *s,-,-,d  |
author          | -,-,-,- | *s,n,e,d  |
contabile       | -,-,-,- | *s,-,-,-  |
tecnico         | -,-,-,- | *s,-,-,-  |
commerciale     | -,-,-,- | *s,-,-,-  |
supervisore     | s,-,-,- | s,-,-,-   |


Tabella Posts
  admin
    show : all records
    new  : no
    edit : all records
    destroy : any record
  moderator
    show : only published records
    new  : no
    edit : no
    destroy : only published records
  author
    show : all published and any of his own records
    new  : yes
    edit : all his own records
    destroy : any of his own record




## enum vs rolify

Questo è l'approccio più flessibile nella gestione dei ruoli. E' come una relazione molti-a-molti con polimorfismo.
Possiamo essere estremamente flessibili, ma nella maggior parte dei casi non ci serve questo livello di flessibilità.

* Se vogliamo gestire un Blog e fare in modo che un autore possa modificare solo i suoi records
  è sufficiente Pundit con una relazione uno a molti user->posts
  altrimenti usiamo Rolify assegnando il ruolo di autore in fase di creazione di articolo (current_user.add_role :author, @post)

* Se, come autori, vogliamo condividere (sharing) un nostro post con altri utenti.
  per avere solo Pundit dobbiamo creare una relazione molti-a-molti con tabella user_post_maps
  altrimenti usiamo Rolify assegnando il ruolo di autore ad un collega con un link reinstradato ad un metodo personalizzato nel controller.

* Se vogliamo gestire che un utente veda solo le transazioni dell'azienda a cui appartiene 
  con solo Pundit dobbiamo creare più relazioni.
  Aggiungendo Rolify usiamo le sue relazioni.

* Se vogliamo assegnare più autorizzazioni ad un utente es: pass_area1, pass_area2, pass_area3
  con solo Pundit dobbiamo creare più campi enum o gestire su un unico campo tutte le combinazioni : 1, 2, 3, 1e2, 1e3, 2e3, 1e2e3.
  aggiungendo Rolify questa gestione è più semplice





# Roles - admin

Questo è l'approccio più semplice della gestione dei ruoli. Esiste solo la possibilità di Amministratore o Utente normale. Quindi è solo aggiungere una colonna boolean nella tabella users.

aggiungiamo il ruolo di amministratore utilizzando un attributo (admin attribute) e non un intero modello.
Questo vuol anche dire aggiungere una colonna "admin" di tipo boolean sulla tabella User invece di creare una nuova tabella Administrators

Nei prossimi capitoli vedremo livelli più alti di gestione dei ruoli:
  
  * enum - ci permette di gestire più ruoli definiti in una colonna integer nella tabella users
  * rolify - massima flessibilità con una gemma ed una tabella roles con relazione molti-a-molti

Volendo usare "rolify" possiamo saltare questo capitolo




## Apriamo il branch "Roles Admin"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b ra
~~~~~~~~




## Aggiungiamo l'attributo admin

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails generate migration add_admin_to_users admin:boolean
~~~~~~~~

Aggiungiamo al migration l'opzione ** defautl: false ** per la colonna admin

{title=".../db/migrate/xxx_add_admin_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddAdminToUsers < ActiveRecord::Migration
  def change
    add_column :users, :admin, :boolean, default: false
  end
end
~~~~~~~~

Eseguiamo il migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rake db:migrate
~~~~~~~~

Adesso possiamo identificare su un utente loggato è amministratore.

{title="verifichiamo se amministratore", lang=ruby, line-numbers=off}
~~~~~~~~
if current_user.admin?
  # do something
end
~~~~~~~~


Se ho un caso particolare in cui una pagina può non avere un utente loggato usiamo .try() per evitare l'errore.
Se *current_user* è *nil* non viene generato un errore (raising an undefined method admin? for nil:NilClass exception)

{title="verifichiamo se amministratore", lang=ruby, line-numbers=off}
~~~~~~~~
if current_user.try(:admin?)
  # do something
end
~~~~~~~~

Se voglio dare i diritti di amministratore (grant admin status) da codice posso:

{title="grant admin status", lang=ruby, line-numbers=off}
~~~~~~~~
current_user.update_attribute :admin, true
~~~~~~~~




## Testiamo la parte di login in produzione.

Abbiamo finito. Non ci resta che fare il "deployment in production" pubblicando la nostra applicazione su heroku.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku login:master
~~~~~~~~

Non funziona perché su heroku non abbiamo eseguito il migrate.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rake db:migrate
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge admin
$ git branch -d admin
~~~~~~~~