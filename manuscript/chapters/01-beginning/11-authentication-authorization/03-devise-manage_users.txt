# Come amministatore creiamo nuovi utenti e gestiamo i loro ruoli



* https://github.com/plataformatec/devise/wiki/How-To:-Manage-users-through-a-CRUD-interface




## Creiamo uno scaffold di esempio

Avendo creato la tabella users con il comando di Devise non ci possiamo avvalere del settaggio impostato dallo "scaffold" ma possiamo comunque prendere come riferimento quello già usato per exampleposts oppure crearcene uno nostro exampleusers.
Creaiamoci un exampleusers che ci rende facile fare copia incolla.


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold ExampleUser email:string password:string password_confirmation:string role:integer
~~~~~~~~

NON eseguiamo $ rails db:migrate così non creaiamo una tabella inutile nel database. (altrimenti avremmo dovuto eliminarla con $rake db:rollback.)
Inoltre eliminiamo il file migrate "db/migrate/xxx_create_example_users.rb" altrimenti riceveremmo un messaggio di errore di migrate:pending.

Finito con i copia/incolla possiamo eliminare i files creati dallo scaffold con 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails destroy scaffold ExampleUser
~~~~~~~~

Tutti i passaggi per tenere uno scaffold temporaneo e poi eliminarlo sarebbero:

* $ rails generate scaffold ...
* $ rails db:migrate
* $ rails db:rollback
* $ rails destroy scaffold ...


P.S.
Uno più smaliziato avrebbe eseguito il "$ rails g scaffold User..." senza eseguire il migrate ed eliminando il file migrate. Ma didatticamente è meglio fare copia/incolla passo-passo.




## Creiamo il controller ed implementiamo l'azione index

Creiamo il nuovo file "users_controller.rb" dentro la cartella controllers, ci copiamo l'intestazione e l'azione index da "example_users_controller.rb" e la riadattiamo

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class UsersController < ApplicationController

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

end
~~~~~~~~




## Aggiorniamo gli instradamenti

Mettiamo gli instradamenti per tutte le azioni Restful di user aggiungendo "resources :users" in basso di "devise_for :users..."

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=9}
~~~~~~~~
  devise_for :users, controllers: {sessions: 'users/sessions', registrations: 'users/registrations'}, path: '', path_names: {sign_in: 'login'}
  resources :users
~~~~~~~~




## Creiamo la view index

Creiamo il nuovo file "index.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/index.html.erb" e lo riadattiamo

{title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<h1>Example Posts</h1>

<table>
  <thead>
    <tr>
      <th>email</th>
      <th>role</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @users.each do |user| %>
      <tr>
        <td><%= user.email %></td>
        <td><%= user.role %></td>
        <td><%= link_to 'Show', user %></td>
        <td><%= link_to 'Edit', edit_user_path(user) %></td>
        <td><%= link_to 'Destroy', user, method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New User', new_user_path %>
~~~~~~~~

Se avessimo voluto tenere tutto organizzato in una sottocartella tipo "views/users/accounts" avremmo dovuto lavorare sul controller e sulla routes come faremo più avanti per authors/posts.




## Verifichiamo che tutto funziona


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
~~~~~~~~

https://rebisworldbr1-flaviobordonidev.c9users.io/users

Continuiamo implementando le altre azioni.




## Implementiamo l'azione show

copiamo ed implementiamo la parte di codice per l'azione show, il before_action lo lascio pronto anche per le prossime azioni.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show, :edit, :update, :destroy]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=10}
~~~~~~~~
  # GET /users/1
  # GET /users/1.json
  def show
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end
~~~~~~~~




## Creiamo la view show

Creiamo il nuovo file "show.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/show.html.erb" e lo riadattiamo

{title=".../app/views/users/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<p>
  <strong>Email:</strong>
  <%= @user.email %>
</p>

<p>
  <strong>Password:</strong>
  <%= @user.password %>
</p>

<p>
  <strong>Password confirmation:</strong>
  <%= @user.password_confirmation %>
</p>

<p>
  <strong>Role:</strong>
  <%= @user.role %>
</p>

<%= link_to 'Edit', edit_user_path(@user) %> |
<%= link_to 'Back', users_path %>
~~~~~~~~




## Implementiamo l'azione edit

copiamo ed implementiamo la parte di codice per l'azione show, il before_action lo lascio pronto anche per le prossime azioni.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/1/edit
  def edit
  end

  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=39}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:email, :password, :password_confirmation, :role)
    end
~~~~~~~~




## Creiamo la view edit

Creiamo i nuovi files "edit.html.erb" e "_form.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto dei files su "views/example_users/..." e lo riadattiamo.

{title=".../app/views/users/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<h1>Editing User</h1>

<%= render 'form', user: @user %>

<%= link_to 'Show', @user %> |
<%= link_to 'Back', users_path %>
~~~~~~~~


{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: user, local: true) do |form| %>
  <% if user.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(user.errors.count, "error") %> prohibited this user from being saved:</h2>

      <ul>
      <% user.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= form.label :email %>
    <%= form.text_field :email %>
  </div>

  <div class="field">
    <%= form.label :password %>
    <%= form.text_field :password %>
  </div>

  <div class="field">
    <%= form.label :password_confirmation %>
    <%= form.text_field :password_confirmation %>
  </div>

  <div class="field">
    <%= form.label :role %>
    <%= form.number_field :role %>
  </div>

  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>
~~~~~~~~

L'update funziona ma possiamo cambiare email e password a tutti, nostro utente compreso. Inoltre le validazioni di Devise ci chiedono sempre di ricambiare la password. Ed il campo role ancora non funziona perché va gestito diversamente essendo definito "enum".
Questi aggiusti li facciamo più avanti nel capitolo.




## Implementiamo l'azione new

copiamo ed implementiamo la parte di codice per l'azione new.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/new
  def new
    @user = User.new
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=24}
~~~~~~~~
  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~




## Creiamo la view new

Creiamo il nuovo file "new.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto del file su "views/example_users/..." e lo riadattiamo.

{title=".../app/views/users/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<h1>New User</h1>

<%= render 'form', user: @user %>

<%= link_to 'Back', users_path %>
~~~~~~~~




## Implementiamo l'azione destroy

copiamo ed implementiamo la parte di codice per l'azione destroy.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy
    respond_to do |format|
      format.html { redirect_to users_url, notice: 'User was successfully destroyed.' }
      format.json { head :no_content }
    end
  end
~~~~~~~~

Adesso che abbiamo finito la parte di copia/incolla rendiamo funzionante il tutto.




## Aggiorniamo la fase di aggiornamento utente

Evitiamo di fare come nei film comici e "tagliarci il ramo su cui stiamo seduti". 
In realtà ce lo tagliamo ma ci logghiamo di nuovo automaticamente col sign_in di Devise bypassando le validazioni.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      # if current_user.present? and current_user == @user
      #   raise "Attento! Current_user #{current_user.email} vuoi modificare te stesso! utente #{@user.email}"
      # elsif current_user.present? and current_user != @user
      #   raise "Current_user #{current_user.email} vuole modificare utente #{@user.email}"
      # else
      #   raise "NON SEI LOGGATO"
      # end
      if current_user.present? and current_user == @user
        if @user.update(user_params)
          #format.html { redirect_to @user, notice: 'User was successfully updated.' }
          format.html do
            # ci siamo tagliati il ramo! Logghiamoci di nuovo automaticamente bypassando le validazioni
            sign_in(@user, bypass: true)
            redirect_to @user, notice: 'User was successfully updated.'
          end
          format.json { render :show, status: :ok, location: @user }
        else
          format.html { render :edit }
          format.json { render json: @user.errors, status: :unprocessable_entity }
        end
      else
        if @user.update(user_params)
          format.html { redirect_to @user, notice: 'User was successfully updated.' }
          format.json { render :show, status: :ok, location: @user }
        else
          format.html { render :edit }
          format.json { render json: @user.errors, status: :unprocessable_entity }
        end
      end
    end
  end
~~~~~~~~

Questo codice funziona ma è veramente brutto perché duplichiamo due grandi pezzi di codice. Facciamo un refactoring.
Il problema è sulla riga "if @user.update(user_params)" che fa sia l'azionie di update che il controllo se è andata a buon fine.
Quando l'update è fatto sull'utente loggato (ossia il current_user) questo è immediatamente buttato fuori (logged out) ed il current_user è svuotato (=nil).
Questo mi impedisce di fare un più elegante ** sign_in(@user, bypass: true) if @user == current_user **
Possiamo farlo usando una variabile di appoggio che chiamiamo current_user_temp e che ci manterrà attivo l'utente che era loggato giusto il tempo di loggarlo di nuovo in automatico.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    current_user_temp = current_user
    respond_to do |format|
      if @user.update(user_params)
        #format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.html do
          # ci siamo tagliati il ramo! Logghiamoci di nuovo automaticamente bypassando le validazioni
          sign_in(@user, bypass: true) if @user == current_user_temp
          redirect_to @user, notice: 'User was successfully updated.'
        end
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

Adesso è molto meglio ^_^




## Evitiamo di dover sempre dare una password

In your UsersController, you will also need to remove the password key of the params hash if it's blank. If not, Devise will fail to validate. Add something like this to your update method:


{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    current_user_temp = current_user

    if params[:user][:password].blank?
      params[:user].delete(:password)
      params[:user].delete(:password_confirmation)
    end
~~~~~~~~




## Evitiamo che l'amministratore loggato possa eliminare se stesso

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=63}
~~~~~~~~
    @user.destroy unless @user == current_user
~~~~~~~~

e diamo un messaggio differente se eliminato o non eliminato

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=60}
~~~~~~~~
  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy unless @user == current_user
    respond_to do |format|
      format.html do 
        redirect_to users_url, notice: 'User was successfully destroyed.' unless @user == current_user
        redirect_to users_url, notice: 'Non posso eliminare utente loggato.' if @user == current_user
      end
      format.json { head :no_content }
    end
  end
~~~~~~~~

sulla view potremmo mostrare il link di eliminazione solo se non è l'utente loggato

~~~~~~~~
  <%= link_to("Delete user", user_path(user), :data => { :confirm => "Are you sure?" }, :method => :delete, :class => 'button-xs') unless user == current_user %>
~~~~~~~~

ma questa gestione la faremo più avanti in maniera più dettagliata usando le autorizzazioni di pundit.




## Evitiamo conflitti 

QUESTO PARAGRAFO NON L'HO IMPLEMENTATO

Since the **registration routes** and **user managing routes** can conflict, you need to change one of them. You can either put devise under a specific prefix:

~~~~~~~~
devise_for :users, :path_prefix => 'my'
resources :users
~~~~~~~~

Or your users

~~~~~~~~
devise_for :users
scope "/admin" do
  resources :users
end
~~~~~~~~




## Permettiamo agli utenti di editare la loro password

QUESTO PARAGRAFO NON L'HO IMPLEMENTATO

Questo non so se mi serve... Mi sa che lo posso eliminare....

ApplicationController.rb:
~~~~~~~~
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  def configure_permitted_parameters
    update_attrs = [:password, :password_confirmation, :current_password]
    devise_parameter_sanitizer.permit :account_update, keys: update_attrs
  end
end
~~~~~~~~

... Questo paragrafo forse è da eliminare *_*




## Risolviamo problema di sicurezza

Al momento tutte le azioni possono essere fatte da chiunque, anche da una pesona non loggata.
Risolviamo prima con l'autorizzazione di pundit e poi con l'obbligo di autenticazione con devise.

Attiviamo pundit per autorizzare le modifiche degli utenti solo se la persona è loggata, quindi è autenticata, ed ha il ruolo di amministratore.

Tutto questo nei prossimi capitoli! La protezione effettiva la iniziamo nel capitolo 7!
07-authorization-pundit.txt
