# Roles - enum

Questo approccio è semplice e permette di avere più ruoli fissi (es: user, vip, admin) o (es: silver, gold, platinum, diamond) 

Nel prossimo capitolo vedremo il livello più alto di gestione dei ruoli:
  
  * rolify - massima flessibilità con una gemma ed una tabella roles con relazione molti-a-molti

Volendo usare "rolify" possiamo saltare questo capitolo


Risorse web:

* [articolo lungo vai al paragrafo Implementing Roles - Enum Roles](http://railsapps.github.io/rails-authorization.html)
* [esempio roles](https://github.com/RailsApps/rails-devise-roles/blob/master/app/views/users/_user.html.erb)
* [esempio pundit](https://github.com/RailsApps/rails-devise-pundit/blob/master/app/views/users/_user.html.erb)

* [Ruby on Rails - how to create perfect enum in 5 steps](https://naturaily.com/blog/ruby-on-rails-enum)
* [Ruby on Rails 5.2.0 - Module - ActiveRecord::Enum](https://api.rubyonrails.org/v5.2.0/classes/ActiveRecord/Enum.html)




## Apriamo il branch "Roles Enum"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b re
~~~~~~~~




## Aggiungiamo il campo roles:enum alla tabella users

nel db postgresql si possono implementare dei campi "enum" ma nel nostro caso restiamo con il semplice "integer" nel db.

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_role_to_users role:integer
~~~~~~~~

Modifichiamo il migrate aggiungendo un default e l'indice per velocizzare queries che usano "role"

{title=".../db/migrate/xxx_create_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddRoleToUsers < ActiveRecord::Migration[5.2]
  def change
    add_column :users, :role, :integer, default: 0
    add_index :users, :role, unique: false
  end
end
~~~~~~~~

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

ed otteniamo le seguenti modifiche alla tabella "users"

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=95}
~~~~~~~~
    t.integer "role", default: 0
    t.index ["email"], name: "index_users_on_email", unique: true
    t.index ["reset_password_token"], name: "index_users_on_reset_password_token", unique: true
    t.index ["role"], name: "index_users_on_role"
  end
~~~~~~~~

Avremmo potuto aggiungere l'indice anche in un secondo momemento

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_index_to_role_to_users
~~~~~~~~

{title=".../db/migrate/xxx_add_index_to_role_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddIndexToRoleToUsers < ActiveRecord::Migration
  def change
    add_index :users, :role, unique: false
  end
end
~~~~~~~~




## Aggiorniamo il Model implementando ENUM

{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  #enum role: [:user, :admin, :moderator, :author]
  enum role: {user: 0, admin: 1, moderator:2, author:3}
~~~~~~~~
  

Se non volessimo usare il default lato database con **, default: 0** potremmo farlo sul model così:  
  
{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  after_initialize :set_default_role, :if => :new_record?

  def set_default_role
    self.role ||= :user
  end
~~~~~~~~




## Aggiorniamo il model

models/user.rb
~~~~~~~~
class User < ApplicationRecord
  enum role: [:user, :vip, :admin]
  after_initialize :set_default_role, :if => :new_record?

  def set_default_role
    self.role ||= :user
  end

  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable
end
~~~~~~~~




## Assegnamo un ruolo ai nostri utenti da console rails

Da "rails console" verifichiamo che:

* tutti gli utenti hanno un campo role con il valore di default "0" ossia, per enum ":user".
* tutti i ruoli presenti nella colonna "role" assegnata ad enum.
* rendiamo il primo utente amministratore
* verifichiamo che ruolo hanno il primo ed il secondo utente
* prendiamo una lista di tutti gli :admin
* prendiamo una lista di tutti gli :user
* prendiamo una lista di tutti i :moderator

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

> User.all
 => #<ActiveRecord::Relation [#<User id: 3, name: "B", email: "bob@test.abc", created_at: "2018-06-20 10:34:00", updated_at: "2018-06-20 10:34:00", role: "user">, #<User id: 4, name: "C", email: "carl@test.abc", created_at: "2018-06-20 10:34:13", updated_at: "2018-06-20 10:34:13", role: "user">, #<User id: 1, name: "Flavio Bordoni", email: "flavio@test.abc", created_at: "2018-06-18 12:32:53", updated_at: "2018-08-08 22:28:52", role: "user">, #<User id: 2, name: "A", email: "ann@test.abc", created_at: "2018-06-20 10:33:45", updated_at: "2018-08-08 22:31:04", role: "user">]> 

> User.roles 
 => {"user"=>0, "admin"=>1, "moderator"=>2, "author"=>3} 

> User.first.admin! 
 User Update (10.2ms)  UPDATE ...
 => true 

# Oppure

> u= User.first 
> u.role = :admin 
> u.save 
 User Update (10.2ms)  UPDATE ...
 => true 

# Oppure

> u= User.first.update(role: :admin)
 User Update (10.2ms)  UPDATE ...
 => true 

> User.first.admin? 
 => true 

> User.second.admin? 
 => false 

> User.first.role
 => "admin" 

> User.second.role
 => "user" 

> User.admin
 => #<ActiveRecord::Relation [#<User id: 1, name: "Flavio Bordoni", email: "flavio@test.abc", created_at: "2018-06-18 12:32:53", updated_at: "2018-08-11 10:19:05", role: "admin">]> 

> User.user
 => #<ActiveRecord::Relation [#<User id: 3, name: "B", email: "bob@test.abc", created_at: "2018-06-20 10:34:00", updated_at: "2018-06-20 10:34:00", role: "user">, #<User id: 4, name: "C", email: "carl@test.abc", created_at: "2018-06-20 10:34:13", updated_at: "2018-06-20 10:34:13", role: "user">, #<User id: 2, name: "A", email: "ann@test.abc", created_at: "2018-06-20 10:33:45", updated_at: "2018-08-08 22:31:04", role: "user">]> 

> User.moderator
 => #<ActiveRecord::Relation []> 

>exit
~~~~~~~~



## Risolviamo il problema di registerable

Siccome precedentemente avevamo tolto registerable perché non ci serviva adesso lo rimettiamo dentro.
Basta aggiornare il model

models/user.rb
~~~~~~~~
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable
~~~~~~~~

e rieseguire il migrate


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails db:migrate
~~~~~~~~

Adesso se riverifichiamo gli instradamenti vediamo che è presente anche "registerable"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes | egrep "user"
~~~~~~~~




## Attiviamo la white list

Invece di cambiare i ruoli da console adesso li cambiamo sulla nostra view.
Abbiamo un piccolo problema. Devise non è come lo scaffold. Non ci crea già le azioni sul controller e le views.

Per poter passare i parametri attraverso le views, o meglio il sumbit del form, dobbiamo inserirli nella white list del controller. Una procedura detta strong-parameters or mass-assignment. Ma questo non è così facile su Devise perché di default ci nasconde tutto.
Abbiamo già visualizzato i controllers e le views di devise-users nei capitoli precedenti.
Possiamo passare i parametri in due modi:

1. Usando il controller application (metodo raccomandato dalla Plataformatec creatrice di Devise)
2. Usando il controller user/registration_controller ma in questo caso dobbiamo dichiararlo nella routes


1. Il metodo raccomandato da plataformatec. Il metodo Lazy way.

* [Ruby on Rails: Customize the devise user (Screencast #1)](https://www.youtube.com/watch?v=5inpxIHKhkE)
* https://github.com/plataformatec/devise

Their names and default permitted parameters are:

sign_in (Devise::SessionsController#create) - Permits only the authentication keys (like email)
sign_up (Devise::RegistrationsController#create) - Permits authentication keys plus password and password_confirmation
account_update (Devise::RegistrationsController#update) - Permits authentication keys plus password, password_confirmation and current_password


{title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_in, keys: [:role])
    devise_parameter_sanitizer.permit(:sign_up, keys: [:role])
    devise_parameter_sanitizer.permit(:account_update, keys: [:role])
  end
end
~~~~~~~~

[tutto il codice](#beginning-authentication-authorization-08a-application_controller.rb)



2. Questa alternativa è una bozza da sistemare meglio

{title=".../app/controllers/users/registrations_controller.rb", lang=ruby, line-numbers=on, starting-line-number=11}
~~~~~~~~
class RegistrationsController < Devise::RegistrationsController

  ...

  private

  def sign_up_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation)
  end

  def account_update_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation, :current_password)
  end
end
~~~~~~~~

Aggiungiamo instradamento users/registrations per devise

{title=".../app/config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=8}
~~~~~~~~
  devise_for :users, controllers: {sessions: 'users/sessions', registration: 'users/registration'}, path: '', path_names: {sign_in: 'login'}
~~~~~~~~





## Implementiamo la view

Aggiungiamo su test/page_a

~~~~~~~~
      <%#= link_to 'Edit Profile', edit_user_registration_path %>
      <%= link_to current_user.email, edit_user_registration_path %>
~~~~~~~~

Aggiungiamo un selettore per permettere di cambiare ruolo

{title=".../app/views/users/registrations/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
~~~~~~~~
  <%= form_for(user) do |f| %>
    <%= f.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
    <%= f.submit 'Change Role', :class => 'button-xs' %>
  <% end %>
~~~~~~~~


  Potrei usare f.collection_select ? 
    <%= f.collection_select(:city_id, City.all, :id, :name) %>
  Credo di no perché questo lavora su una tabella; invece noi stiamo usando |enum| sulla colonna :role della tabella users.
  
  Altro esempio di f.select per chiarire meglio come lavora
  ~~~~~~~~
  <%= form_for @post do |f| %>
    <%= f.select :person_id, Person.all.map { |p| [ p.name, p.id ] }, include_blank: true %>
    <%= f.submit %>
  <% end %>
  ~~~~~~~~
  
  ~~~~~~~~
  @users = User.all
  <% form_for @user, :html => { :method => :post } do |f| %>
    <%= f.select :user_id, @users %>
  ~~~~~~~~
  
  ~~~~~~~~
  <% form_for @user, :html => { :method => :post } do |f| %>
    <%= f.select :user_id, @users.collect { |user| [user.name, user.id] } %>
  ~~~~~~~~
  
  ~~~~~~~~
  <%= f.select :estados, ['SP', 'PA', 'RJ'] %>
  ~~~~~~~~
  
  ~~~~~~~~
  <%= f.select :estados, [['São Paulo', 'SP'], ['Pará', 'PA'], ['Rio de Janeiro', 'RJ']] %>
  ~~~~~~~~

  


## Differenza fra each, map, collect

http://queirozf.com/entries/ruby-map-each-collect-inject-reject-select-quick-reference

collect 
Alias for map

map
Performs an action on each array element. The original array is not modified. Returns the modified array.

[1,2,3,4,5,6,7,8,9,10].map{|e| e*3 }
# returns [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]

each
Executes an action using as parameter each element of the array. Returns the unmodified array.

[1,2,3,4,5,6,7,8,9,10].each{|e| print e.to_s+"!" }
# prints "1!2!3!4!5!6!7!8!9!10!"
# returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 


https://stackoverflow.com/questions/9429034/what-is-the-difference-between-map-each-and-collect

each is different from map and collect, 
but map and collect are the same (technically map is an alias for collect, but in my experience map is used a lot more frequently).
map is the community-choosen version ( https://github.com/bbatsov/ruby-style-guide#map-fine-select-reduce-size )

each performs the enclosed block for each element in the (Enumerable) receiver:

[1,2,3,4].each {|n| puts n*2}
# Outputs:
# 2
# 4
# 6
# 8

map and collect produce a new Array containing the results of the block applied to each element of the receiver:

[1,2,3,4].map {|n| n*2}
# => [2,4,6,8]

There's also map! / collect! defined on Arrays; they modify the receiver in place:

a = [1,2,3,4]

a.map {|n| n*2} # => [2,4,6,8]
puts a.inspect  # prints: "[1,2,3,4]"

a.map! {|n| n+1}
puts a.inspect  # prints: "[2,3,4,5]"




## Un momento solo admin deve poter cambiare il ruolo

Inseriamo un controllo nel selettore che permettere di cambiare ruolo

{title=".../app/views/users/registrations/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
~~~~~~~~
  <% if user_signed_in? and current_user.admin? %>
  <%# if current_user.present? and current_user.admin? %>
    <%= form_for(user) do |f| %>
      <%= f.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
      <%= f.submit 'Change Role', :class => 'button-xs' %>
    <% end %>
  <% end %>
~~~~~~~~

Se ti stai domandando qual'è la differenza fra user_signed_in? e current_user.present? la risposta è "non c'è nessuna differenza". (https://stackoverflow.com/questions/45398702/what-is-the-difference-between-current-user-present-and-if-user-signed-in)

Adesso solo se l'utente è amministratore può cambiare i ruoli.

Per evitare che si cambi il suo ruolo metterei

 unless user == current_user




## CAZZO ho sbagliato

Register permette di fare i cambi solo per l'utente che è loggato. noi invece vogliamo una gestione come amministratore di vedere tutti gli utenti e cambiare i ruoli degli altri utenti.

 *_*

Devo rivedere questo MERDA!








## Elimina utente ma non te stesso

  <%= link_to("Delete user", user_path(user), :data => { :confirm => "Are you sure?" }, :method => :delete, :class => 'button-xs') unless user == current_user %>
