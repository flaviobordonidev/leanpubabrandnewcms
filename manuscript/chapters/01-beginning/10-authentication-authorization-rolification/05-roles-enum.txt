# Roles - enum

Questo approccio è semplice e permette di avere più ruoli fissi (es: user, vip, admin) o (es: silver, gold, platinum, diamond) 

Nel prossimo capitolo vedremo il livello più alto di gestione dei ruoli:
  
  * rolify - massima flessibilità con una gemma ed una tabella roles con relazione molti-a-molti

Volendo usare "rolify" possiamo saltare questo capitolo


Risorse web:

* [articolo lungo vai al paragrafo Implementing Roles - Enum Roles](http://railsapps.github.io/rails-authorization.html)




## Apriamo il branch "Roles Enum"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b re
~~~~~~~~



    For an enum attribute named role, with the values admin, vip, and user, we can use these methods:
    
    User.roles # => {"user"=>0, "vip"=>1, "admin"=>2} – list all roles
    user.admin! – make the user an administrator
    user.admin? # => true – query if the user is an administrator
    user.role # => "admin" – find out the user’s role
    @users = User.admin – obtain an array of all users with the admin role
    user.role = 'foo' # ArgumentError: 'foo' is not a valid role – we can’t set invalid roles
    
    Active Record automatically gives you convenience methods to assign and query any role. For example, in a User model, if you have:
    
    enum role: [:coach, :business, :first, :crew]
    You’ll automatically get the following methods anywhere you’ve instantiated the user object:
    
    user.coach! – assign the user’s role
    user.business!
    user.first!
    user.crew!
    user.coach? – query the user’s role
    user.business?
    user.first?
    user.crew?
    
    Active Record enums make it easy to add role-based authorization to a Rails application.


Guarda questi esempi

https://github.com/RailsApps/rails-devise-roles/blob/master/app/views/users/_user.html.erb
https://github.com/RailsApps/rails-devise-pundit/blob/master/app/views/users/_user.html.erb

views/users/_user
~~~~~~~~
  <%= form_for(user) do |f| %>
    <%= f.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
    <%= f.submit 'Change Role', :class => 'button-xs' %>
  <% end %>
~~~~~~~~


      Potrei usare f.collection_select ? 
        <%= f.collection_select(:city_id, City.all, :id, :name) %>
      Credo di no perché questo lavora su una tabella; invece noi stiamo usando |enum| sulla colonna :role della tabella users.
      
      Altro esempio di f.select per chiarire meglio come lavora
      ~~~~~~~~
      <%= form_for @post do |f| %>
        <%= f.select :person_id, Person.all.map { |p| [ p.name, p.id ] }, include_blank: true %>
        <%= f.submit %>
      <% end %>
      ~~~~~~~~
      
      ~~~~~~~~
      @users = User.all
      <% form_for @user, :html => { :method => :post } do |f| %>
        <%= f.select :user_id, @users %>
      ~~~~~~~~
      
      ~~~~~~~~
      <% form_for @user, :html => { :method => :post } do |f| %>
        <%= f.select :user_id, @users.collect { |user| [user.name, user.id] } %>
      ~~~~~~~~
      
      ~~~~~~~~
      <%= f.select :estados, ['SP', 'PA', 'RJ'] %>
      ~~~~~~~~
      
      ~~~~~~~~
      <%= f.select :estados, [['São Paulo', 'SP'], ['Pará', 'PA'], ['Rio de Janeiro', 'RJ']] %>
      ~~~~~~~~
      

models/user.rb
~~~~~~~~
class User < ApplicationRecord
  enum role: [:user, :vip, :admin]
  after_initialize :set_default_role, :if => :new_record?

  def set_default_role
    self.role ||= :user
  end

  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable
end
~~~~~~~~



## Differenza fra each, map, collect

http://queirozf.com/entries/ruby-map-each-collect-inject-reject-select-quick-reference

collect 
Alias for map

map
Performs an action on each array element. The original array is not modified. Returns the modified array.

[1,2,3,4,5,6,7,8,9,10].map{|e| e*3 }
# returns [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]

each
Executes an action using as parameter each element of the array. Returns the unmodified array.

[1,2,3,4,5,6,7,8,9,10].each{|e| print e.to_s+"!" }
# prints "1!2!3!4!5!6!7!8!9!10!"
# returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 


https://stackoverflow.com/questions/9429034/what-is-the-difference-between-map-each-and-collect

each is different from map and collect, 
but map and collect are the same (technically map is an alias for collect, but in my experience map is used a lot more frequently).
map is the community-choosen version ( https://github.com/bbatsov/ruby-style-guide#map-fine-select-reduce-size )

each performs the enclosed block for each element in the (Enumerable) receiver:

[1,2,3,4].each {|n| puts n*2}
# Outputs:
# 2
# 4
# 6
# 8

map and collect produce a new Array containing the results of the block applied to each element of the receiver:

[1,2,3,4].map {|n| n*2}
# => [2,4,6,8]

There's also map! / collect! defined on Arrays; they modify the receiver in place:

a = [1,2,3,4]

a.map {|n| n*2} # => [2,4,6,8]
puts a.inspect  # prints: "[1,2,3,4]"

a.map! {|n| n+1}
puts a.inspect  # prints: "[2,3,4,5]"




## Elimina utente ma non te stesso

  <%= link_to("Delete user", user_path(user), :data => { :confirm => "Are you sure?" }, :method => :delete, :class => 'button-xs') unless user == current_user %>
