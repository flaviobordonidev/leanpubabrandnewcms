# Roles - enum

Questo è l'approccio più flessibile nella gestione dei ruoli.

* Se vogliamo gestire un Blog e fare in modo che un autore possa modificare solo i suoi records ci serve Rolify.
* Se vogliamo gestire che un utente veda solo le transazioni dell'azienda a cui appartiene ci serve Rolify.
* ...


Risorse web:

* [Rolify wiki - usage](https://github.com/RolifyCommunity/rolify/wiki/Usage)
* [Rolify wiki](https://github.com/EppO/rolify/wiki)
* [Rolify community](https://github.com/RolifyCommunity/rolify)
* [Sito brasileiro](http://groselhas.maurogeorge.com.br/rolify-com-pundit-para-uma-autorizacao-com-multiplos-papeis.html)
  http://groselhas.maurogeorge.com.br/rolify-com-pundit-para-uma-autorizacao-com-multiplos-papeis.html#sthash.qfwFjKhJ.dpbs

* https://github.com/elabs/pundit
* https://github.com/RolifyCommunity/rolify
* http://eng.joingrouper.com/blog/2014/03/20/rails-the-missing-parts-policies/
* http://railsapps.github.io/rails-authorization.html
* https://github.com/RolifyCommunity/rolify/wiki


* [sitepoint - Straightforward Rails Authorization with Pundit](https://www.sitepoint.com/straightforward-rails-authorization-with-pundit/)
* [Pundit](https://github.com/elabs/pundit)
* [Rails Authorization With Pundit](https://www.youtube.com/watch?v=qruGD_8ry7k)




## Apriamo il branch "Roles Rolify"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b rr
~~~~~~~~




## Installiamo la gemma rolify

I> verifichiamo [l'ultima versione della gemma](https://rubygems.org/gems/rolify)
I>
I> facciamo riferimento al [tutorial github della gemma](https://github.com/RolifyCommunity/rolify)

{title="Gemfile", lang=ruby, line-numbers=on, starting-line-number=43}
~~~~~~~~
# Very simple Roles library
gem 'rolify', '~> 5.2'
~~~~~~~~

[tutto il codice: Gemfile](#beginning-authentication-authorization-rolification-02a-Gemfile)

Eseguiamo l'installazione della gemma con bundle

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ bundle install
~~~~~~~~



## Creiamo le classi per rolify

Creiamo le classi "Role" e "User" per definire i ruoli. Sono le classi di default e la classe "User" combina con la scelta "user" di default di devise.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g rolify Role User

# ===============================================================================
# 
# An initializer file has been created here: config/initializers/rolify.rb, you 
# can change rolify settings to match your needs. 
# Defaults values are commented out.
# 
# A Role class has been created in app/models (with the name you gave as 
# argument otherwise the default is role.rb), you can add your own business logic 
# inside.
# 
# Inside your User class (or the name you gave as argument otherwise the default 
# is user.rb), rolify method has been inserted to provide rolify methods.
~~~~~~~~

lo script:
* crea il nuovo modello role.rb
* aggiunge del codice nel modello user.rb 
* crea config/initializers/rolify.rb
* crea il seguente migrate

{title=".../db/migrate/xxx_rolify_create_roles.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class RolifyCreateRoles < ActiveRecord::Migration[5.2]
  def change
    create_table(:roles) do |t|
      t.string :name
      t.references :resource, :polymorphic => true

      t.timestamps
    end

    create_table(:users_roles, :id => false) do |t|
      t.references :user
      t.references :role
    end
    
    add_index(:roles, [ :name, :resource_type, :resource_id ])
    add_index(:users_roles, [ :user_id, :role_id ])
  end
end
~~~~~~~~

eseguiamo il migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

l'impostazione base è terminata possiamo già usare rolify.




## Aggiungiamo degli utenti da console 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> User.create(name: 'A', email: 'ann@test.abc', password: 'password', password_confirmation: 'password')
> User.create(name: 'B', email: 'bob@test.abc', password: 'password', password_confirmation: 'password')
> User.create(name: 'C', email: 'carl@test.abc', password: 'password', password_confirmation: 'password')
> exit
~~~~~~~~



## Associamo e verifichiamo dei ruoli da console

Associamo e togliamo un ruolo al primo utente disponibile.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> User.first.add_role :admin
> User.first.remove_role :admin
~~~~~~~~

vediamo adesso degli scenari di utilizzo



### Scenario con solo admin (come roles-admin)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

  # Definiamo un ruolo globale
> user = User.find(1)
> user.has_role? :admin
=> false
> user.add_role :admin
> user.has_role? :admin
=> true
> user.remove_role :admin
> user.has_role? :admin
=> false
~~~~~~~~




### Scenario con silver, gold, platinum (come roles-enum)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

> u1 = User.find(1)
> u1.add_role :silver

> u2 = User.find(2)
> u2.add_role :gold

> u3 = User.find(3)
> u3.add_role :platinum

> u1.has_role? :silver
=> true
> u1.has_role? :gold
=> false
> u1.has_role? :platinum
=> false

> u2.has_role? :silver
=> false
> u2.has_role? :gold
=> true
> u2.has_role? :platinum
=> false

> u3.has_role? :silver
=> false
> u3.has_role? :gold
=> false
> u3.has_role? :platinum
=> true

> u1.remove_role :silver
> u2.remove_role :gold
> u3.remove_role :platinum
~~~~~~~~





### Scenario con silver, gold, platinum ed in aggiunta bonus

In questo caso oltre il ruolo tipo "enum" (silver o gold o platinum) posso avere in aggiunta un ruolo "bonus" (es: gold e bonus)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

> u1 = User.find(1)
> u1.add_role :gold
> u1.add_role :bonus

> u2 = User.find(1)
> u2.add_role :gold

> u1.has_role? :silver
=> false
> u1.has_role? :gold
=> true
> u1.has_role? :platinum
=> false
> u1.has_role? :bonus
=> true

> u2.has_role? :silver
=> false
> u2.has_role? :gold
=> true
> u2.has_role? :platinum
=> false
> u2.has_role? :bonus
=> false

> u1.remove_role :silver
> u1.remove_role :bonus
> u2.remove_role :gold
~~~~~~~~




### Scenario pass di accesso

In questo scenario l'utente 1 ha accesso a cucina, sala e bagno mentre l'utente 2 ha accesso solo a sala e bagno

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

> u1 = User.find(1)
> u1.add_role :cucina
> u1.add_role :sala
> u1.add_role :bagno

> u2 = User.find(1)
> u2.add_role :sala
> u2.add_role :bagno

> u1.has_role? :cucina
=> true
> u1.has_role? :sala
=> true
> u1.has_role? :bagno
=> true
> u1.has_role? :camera_da_letto
=> false

> u2.has_role? :cucina
=> false
> u2.has_role? :sala
=> true
> u2.has_role? :bagno
=> true
> u2.has_role? :camera_da_letto
=> false

> u1.remove_role :cucina
> u1.remove_role :sala
> u1.remove_role :bagno
> u2.remove_role :sala
> u2.remove_role :bagno
~~~~~~~~




## Impementiamo tabella example_posts per gli scenari con Blog e con Forum

implementiamo tutta la gestione degli articoli come esempio inclusa la tabella example_posts per gestire gli articoli creati da utenti con ruolo di autore.
Generiamo tutto lo **scaffold** perché vogliamo anche i controllers e le views. 
 - il **migrate** crea la sola tabella
 - il **model** oltre alla tabella crea il model per il collegamento uno-a-molti.
 - lo **scaffold** crea anche il controller e le views.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold ExamplePost title:string incipit:text user:references
~~~~~~~~

La cosa bella di **user_references** è che, oltre a creare la colonna **user_id:integer**, ci aggiunge anche l'indice in tabella e ci predispone la relazione uno-a-molti.

vediamo il migrate creato

{title=".../db/migrate/xxx_create_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreatePosts < ActiveRecord::Migration[5.2]
  def change
    create_table :posts do |t|
      t.string :title
      t.text :incipit
      t.references :user, foreign_key: true

      t.timestamps
    end
  end
end
~~~~~~~~

la **t.references :user, foreign_key: true** è uguale a:

~~~~~~~~
  ...
    t.string :user_id
  end
  ...
  
  add_index :posts, :user_id

## da verificare perché credo di aver sbagliato qualcosa
~~~~~~~~


eseguiamo il migrate 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




### Completiamo la relazione uno-a-molti

Oltre la relazione uno-a-molti aggiungiamo la chiamata **resourcify** per permettere alla gemma rolify di creare ruoli basati sui posts

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  resourcify

  belongs_to :user
~~~~~~~~

{title=".../app/models/user.rb", lang=ruby, line-numbers=on, starting-line-number=9}
~~~~~~~~
  rolify

  has_many :posts
~~~~~~~~




### Inseriamo qualche articolo da console

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> u1 = User.find(1)
> u1.posts.create(title: "Il mio primo articolo", incipit: "Perché scrivere questo articolo")
> u1.posts.create(title: "Il mio secondo articolo", incipit: "Ci ho preso gusto")
> u1.posts.create(title: "Il mio terzo articolo", incipit: "Adesso sono esperto")

> u2 = User.find(2)
> u2.posts.create(title: "La conferenza uno", incipit: "Una interessante conferenza sul cielo")
> u2.posts.create(title: "La conferenza due", incipit: "Perché si formano le nuvole? Capiamo il ciclo dell'acqua")
> u2.posts.create(title: "La conferenza tre", incipit: "Il sole è una stella nana")


> u3 = User.find(3)
> u3.posts.create(title: "Studio di caso alfa", incipit: "In questo studio la nostra azienda è stata brava")
> u3.posts.create(title: "Studio di caso beta", incipit: "In questo studio identifichiamo i pesci nell'acquario")
> u3.posts.create(title: "Studio di caso gamma", incipit: "Questo studio è praticamente identico a quello dell'architetto")

> exit
~~~~~~~~




## Scenario storico di un blog con moderatore

Non vengono più scritti o modificati articoli ma gli utenti con ruolo di moderatore possono cancellare qualsiasi articolo.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

  # Definiamo un ruolo per una classe
> user = User.find(1)
> user.add_role :moderator, Post

> user.has_role? :moderator
=> false
> user.has_role? :moderator, Post
=> true
> user.has_role? :moderator, Post.first
=> true
> user.has_role? :moderator, Post.find(5)
=> true
> user.has_role? :moderator, Post.last
=> true

> user.remove_role :moderator, Post
~~~~~~~~

In questo esempio il primo utente ha il ruolo :moderator per tutti gli articoli (a livello di classe Post) ma non a livello globale.




## Scenario blog con autori

In questo scenario 
* ogni utente con o senza ruolo ha accesso alla lettura di tutti gli articoli
* ogni utente con ruolo di autore ha accesso alla modifica solo dei suoi articoli


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

  # Definiamo un ruolo per una classe
> u1 = User.find(1)
> u1.add_role :moderator, Post

> u2 = User.find(2)
> u2.add_role :moderator, Post.find(4)
> u2.add_role :moderator, Post.find(2)


  # richiamiamo tutti gli articoli che hanno un moderatore
> Post.with_role(:moderator)

  # richiamiamo tutti gli articoli per cui u1 è moderatore
> Post.with_role(:moderator, u1)

  # richiamiamo tutti gli articoli per cui u2 è moderatore
> Post.with_role(:moderator, u2)

  # richiamiamo gli articoli di u1 per cui u1 è moderatore
> u1.posts.with_roles(:moderator, u1)

  # richiamiamo gli articoli di u1 per cui u2 è moderatore
> u1.posts.with_roles(:moderator, u2)

  # richiamiamo gli articoli di u2 per cui u2 è moderatore
> u2.posts.with_roles(:moderator, u2)

  # richiamiamo gli articoli di u2 per cui u1 è moderatore
> u2.posts.with_roles(:moderator, u1)
  
  # togliamo un ruolo ad u1 per l'istanza 2
> u1.remove_role :moderator, Post.find(2)

  # richiamiamo gli articoli di u1 per cui u1 è moderatore
> u1.posts.with_roles(:moderator, u1)

  # togliamo globalmente il ruolo :moderator ad u1 e u2
> u1.remove_role :moderator
> u2.remove_role :moderator

> user.remove_role :moderator, Post
~~~~~~~~







## Scenario blog con autori e moderatore

In questo scenario 
* ogni utente con o senza ruolo ha accesso alla lettura di tutti gli articoli
* ogni utente con ruolo di autore ha accesso alla modifica solo dei suoi articoli
* ogni utente con ruolo di moderatore ha accesso alla modifica di tutti gli articoli




## Scenario forum

per questo scenario usiamo la tabella posts come se fosse la tabella forums.
Un utente che può creare dei suoi articoli e cancellarli deve avere i ruoli sia di autore che di moderatore.
In questo scenario 
* ogni utente con o senza ruolo ha accesso alla lettura di tutti gli articoli
* ogni utente con ruolo di autore ha accesso alla creazione/modifica solo dei suoi articoli
* ogni utente con ruolo di moderatore ha accesso alla sola eliminazione di tutti gli articoli





## Impementiamo tabella companies per scenari più complessi

implementiamo temporaneamente la tabella companies per gestire scenari più complessi




## Scenario articoli aziendali privati

In questo scenario
* Ogni utente che non appartiene a nessuna azienda non può vedere nessun articolo
* Ogni utente con o senza ruolo, che appartiene ad una o più aziende, ha accesso alla lettura di tutti gli articoli delle aziende a cui appartiene
* Ogni utente con ruolo moderatore, che appartiene ad una o più aziende, può modificare tutti gli articoli delle aziende a cui appartiene
* Ogni utente con ruolo autore, che appartiene ad una o più aziende, può modificare solo i suoi articoli delle aziende a cui appartiene



{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

  # Definiamo un ruolo globale
> user = User.find(1)
> user.add_role :admin
> user.has_role? :admin
=> true

  # Definiamo un ruolo per una classe
> user = User.find(3)
> user.add_role :moderator, Forum
> user.has_role? :moderator, Forum
=> true
> user.has_role? :moderator, Forum.first
=> true
> user.has_role? :moderator, Forum.last
=> true

  # Definiamo un ruolo per una istanza specifica
> user = User.find(2)
> user.add_role :moderator, Forum.first
> user.has_role? :moderator, Forum.first
=> true
> user.has_role? :moderator, Forum.last
=> false

  # Rimuoviamo un ruolo
> user = User.find(3)
> user.remove_role :moderator
~~~~~~~~




A global role overrides resource role request:

user = User.find(4)
user.add_role :moderator # sets a global role
user.has_role? :moderator, Forum.first
=> true
user.has_role? :moderator, Forum.last
=> true
6. Resource roles querying
Starting from rolify 3.0, you can search roles on instance level or class level resources.

Instance level
forum = Forum.first
forum.roles
# => [ list of roles that are only bound to forum instance ]
forum.applied_roles
# => [ list of roles bound to forum instance and to the Forum class ]
Class level
Forum.with_role(:admin)
# => [ list of Forum instances that have role "admin" bound to them ]
Forum.without_role(:admin)
# => [ list of Forum instances that do NOT have role "admin" bound to them ]
Forum.with_role(:admin, current_user)
# => [ list of Forum instances that have role "admin" bound to them and belong to current_user roles ]
Forum.with_roles([:admin, :user], current_user)
# => [ list of Forum instances that have role "admin" or "user" bound to them and belong to current_user roles ]

User.with_any_role(:user, :admin)
# => [ list of User instances that have role "admin" or "user" bound to them ]
User.with_role(:site_admin, current_site)
# => [ list of User instances that have a scoped role of "site_admin" to a site instance ]
User.with_role(:site_admin, :any)
# => [ list of User instances that have a scoped role of "site_admin" for any site instances ]
User.with_all_roles(:site_admin, :admin)
# => [ list of User instances that have a role of "site_admin" and a role of "admin" bound to it ]

Forum.find_roles
# => [ list of roles that are bound to any Forum instance or to the Forum class ]
Forum.find_roles(:admin)
# => [ list of roles that are bound to any Forum instance or to the Forum class, with "admin" as a role name ]
Forum.find_roles(:admin, current_user)
# => [ list of roles that are bound to any Forum instance, or to the Forum class with "admin" as a role name, and belongs to current_user ]








## Fine degli scenari torniamo indietro

Effettuiamo il roll-back dei migrate delle due tabelle temporanee companies e posts in modo da eliminare tutto.

# rollback bla bla ... vedi leanpubrailsresources






## Artigo Brasileiro

No sistema de gerenciamento de empresas temos 3 papeis: 
* O Gerente pode visualizar todas as telas do sistema. 
* O empregado não pode criar, editar ou excluir nenhuma empresa. 
* O investidor deve visualizar apenas as empresas em que ele investe.

Pois eu devo poder definir para cada um dos investidores quais empresas ele tem acesso, supondo que tenhamos as empresas A, B e C, deve ser possivel dizer que o investidor tem o papel investidor apenas na empresa A e C, ou seja ele possui 2 papeis diferentes.

Simplesmente adicionamos o macro resourcify no model que queremos utilizar na definição dos papeis.

~~~~~~~~
class Company < ActiveRecord::Base
  # ...

  resourcify
end
~~~~~~~~


user.add_role :investor, company
user.remove_role :investor, company


O Rolify nos fornece um model Role então o que temos que fazer é apenas definir as validações de inclusão no mesmo.

class Role < ActiveRecord::Base

  NAMES = %w{ investor }
  RESOURCE_TYPES = %w{ Company }

  validates :name, inclusion: { in: NAMES }
  validates :resource_type, inclusion: { in: RESOURCE_TYPES }

  # ...
end



Company.with_role(:investor, user)

Assim temos todas as empresas em que o user é investidor, com uma simples chamada de método.


class CompanyPolicy < ApplicationPolicy

  # ...

  class Scope < Scope
    def resolve
      if user.has_role?(:investor, :any)
        scope.with_role(:investor, user)
      else
        scope.all
      end
    end
  end
end

def index
  @companies = policy_scope(Company)
end








********
********

https://github.com/plataformatec/devise/wiki/How-To:-Add-a-default-role-to-a-User

class User < ActiveRecord::Base
  belongs_to :role
  before_create :set_default_role
  # or 
  # before_validation :set_default_role 

  private
  def set_default_role
    self.role ||= Role.find_by_name('registered')
  end
end




https://github.com/RolifyCommunity/rolify

Very simple Roles library without any authorization enforcement supporting scope on resource object.

Let's see an example:

user.has_role?(:moderator, Forum.first)
=> false # if user is moderator of another Forum
This library can be easily integrated with any authentication gem (devise, Authlogic, Clearance) and authorization gem* (CanCanCan, authority)

*: authorization gem that doesn't provide a role class

---

controller
  before_filter :authorize, only: :edit

private

  def authorize
    if current_user && !current_user.admin?
      redirect_to root_url, alert: "Not authorized."
    end
  end

end

Questo funziona ma ha limiti e qualche buco. Spostiamo l'autorizzazione al livello di model.
Iniziamo creando l'oggetto "current_permission"

def current_permission
  @current_permission ||= Permission.new(current_user)
end

def authorize
  if !current_permission.allow?
    ...
  end
end

Dentro il model creo una classe (anche se non eredita da rails)

class Permission < Struct.new(:user)
  def allow?
    user && user.admin?
  end
end
