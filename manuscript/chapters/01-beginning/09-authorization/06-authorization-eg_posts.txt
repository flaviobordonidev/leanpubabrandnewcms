# Implementiamo le autorizzazioni per example_posts

In questo capitolo inseriamo meno passaggi e meno spiegazioni rispetto al capitolo precedente.



## Apriamo il branch "Authorization ExamplePost"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b aep
~~~~~~~~




## Aggiungiamo policy per ExamplePost

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g pundit:policy EgPost


ec2-user:~/environment/myapp (aep) $ rails g pundit:policy ExamplePost
Running via Spring preloader in process 4105
      create  app/policies/example_post_policy.rb
      invoke  test_unit
      create    test/policies/example_post_policy_test.rb
~~~~~~~~

questo crea la seguente policy

{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ExamplePostPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
~~~~~~~~



## Implementiamo tutte le policies per tutte le azioni di eg_posts

Vediamo uno schema della logica delle autorizzazioni

Legenda:
 * per "records" si intendono gli "articoli di esempio" (eg_posts)
 * per "propri records" si intendono gli "articoli di esempio di cui l'utente è proprietario". Ossia dove ha una relazione uno-a-molti.

index
 * Utente non loggato           : autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

show
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

new/create
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato SOLO sui propri records


edit/update
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

destroy
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records


{title=".../app/policies/eg_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  def index?
    true
  end

  def show?
    if @user.present?
      true
    else
      false
    end
  end
  
  def create?
    if @user.present?
      @user.author? or @user.moderator? or @user.admin?
    else
      false
    end
  end
  
  def update?
    if @user.present?
      if @user.user?
        false
      else
        @user.id == @record.user_id or @user.admin?
      end
    else
      false
    end
  end

  def destroy?
    if @user.present?
      @user.id == @record.user_id or @user.moderator? or @user.admin?
    else
      false
    end
  end
~~~~~~~~

Facciamo dei piccoli refactoring

{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  def show?
    @user.present?
  end
~~~~~~~~

ottengo già true o false e quindi non mi serve un ciclo if...else...end

{id="01-09-06_01", title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  def update?
    if @user.present?
      @user.id == @record.user_id or @user.admin?
    else
      false
    end
  end
~~~~~~~~

[Codice 01](#01-09-06_01all)

Questo autorizzerebbe l'user a modificare i suoi propri record ma non potendoli creare non ha record da modificare.




## Implementiamo nel controller

{id="01-09-06_02", title=".../app/controllers/eg_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=6}
~~~~~~~~
  def index
    @eg_posts = EgPost.all
    authorize @eg_posts
~~~~~~~~

{title=".../app/controllers/eg_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=17}
~~~~~~~~
  def new
    @eg_post = EgPost.new
    authorize @eg_post
~~~~~~~~

{title=".../app/controllers/eg_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=28}
~~~~~~~~
  def create
    @eg_post = EgPost.new(eg_post_params)
    authorize @eg_post
~~~~~~~~

Per le azioni [:show, :edit, :update, :destroy], che chiamano la funzione "set_user" con il before_action, inserisco l'autorizzazione direttamente sulla funzione "set_user"

{title=".../app/controllers/eg_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=71}
~~~~~~~~
    def set_eg_post
      @eg_post = EgPost.find(params[:id])
      authorize @eg_post
~~~~~~~~

[Codice 02](#01-09-06_02all)




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/example_posts




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "add pundit authorization on all actions of example_post"
~~~~~~~~




## Un refactoring sulla logica della policy

riportiamo la gestione della logica della policy ad una situazione simile schema della logica delle autorizzazioni: 

index
 * Utente non loggato           : autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

show
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

new/create
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato SOLO sui propri records


edit/update
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

destroy
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records


{id="01-09-06_03", title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  def index?
    if @user.present?
      case @user.role
      when 'user'
        true
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      true
    end
  end

  def show?
    if @user.present?
      case @user.role
      when 'user'
        true
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
  
  def create?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
  
  def update?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        @user.id == @record.user_id
      when 'moderator'
        @user.id == @record.user_id
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end

  def destroy?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        @user.id == @record.user_id
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
~~~~~~~~

[Codice 03](#01-09-06_03all)

In questo modo mi è molto più chiaro capire la logica delle autorizzazioni.




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/example_posts




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Refactor policies conditions like the logical schema"
~~~~~~~~




## Publichiamo su heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku aep:master
$ heroku run rake db:migrate
~~~~~~~~

Ricordiamo che lato produzione su heroku c'è un database indipendente da quello di sviluppo. Se si è seguito il tutorial avremo la tabella già con i records inseriti e quindi speculare a quella di sviluppo.




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge aep
$ git branch -d aep
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~




## Il codice del capitolo





[Codice 01](#01-09-06_01)

{id="01-09-06_01all", title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ExamplePostPolicy < ApplicationPolicy

  def index?
    true
  end

  def show?
    @user.present?
  end
  
  def create?
    if @user.present?
      @user.author? or @user.moderator? or @user.admin?
    else
      false
    end
  end
  
  def update?
    if @user.present?
      @user.id == @record.user_id or @user.admin?
    else
      false
    end
  end

  def destroy?
    if @user.present?
      @user.id == @record.user_id or @user.moderator? or @user.admin?
    else
      false
    end
  end

  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
~~~~~~~~




[Codice 02](#01-09-06_02)

{id="01-09-06_02all", title=".../app/controllers/example_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ExamplePostsController < ApplicationController
  before_action :set_example_post, only: [:show, :edit, :update, :destroy]

  # GET /example_posts
  # GET /example_posts.json
  def index
    @example_posts = ExamplePost.all
    authorize @example_posts
  end

  # GET /example_posts/1
  # GET /example_posts/1.json
  def show
    authorize @example_post
  end

  # GET /example_posts/new
  def new
    @example_post = ExamplePost.new
    #raise "merda: #{current_user}"
    authorize @example_post
  end

  # GET /example_posts/1/edit
  def edit
    authorize @example_post
  end

  # POST /example_posts
  # POST /example_posts.json
  def create
    @example_post = ExamplePost.new(example_post_params)
    #@example_post.user = current_user
    authorize @example_post
    
    respond_to do |format|
      if @example_post.save
        format.html { redirect_to @example_post, notice: 'Example post was successfully created.' }
        format.json { render :show, status: :created, location: @example_post }
      else
        format.html { render :new }
        format.json { render json: @example_post.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /example_posts/1
  # PATCH/PUT /example_posts/1.json
  def update
    authorize @example_post
    respond_to do |format|
      if @example_post.update(example_post_params)
        format.html { redirect_to @example_post, notice: 'Example post was successfully updated.' }
        format.json { render :show, status: :ok, location: @example_post }
      else
        format.html { render :edit }
        format.json { render json: @example_post.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /example_posts/1
  # DELETE /example_posts/1.json
  def destroy
    authorize @example_post
    @example_post.destroy
    respond_to do |format|
      format.html { redirect_to example_posts_url, notice: 'Example post was successfully destroyed.' }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_example_post
      @example_post = ExamplePost.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def example_post_params
      params.require(:example_post).permit(:title, :incipit, :user_id, :header_image)
    end
end
~~~~~~~~
