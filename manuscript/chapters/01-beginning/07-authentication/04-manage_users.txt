# Implementiamo la gestione degli utenti

Gestiamo gli utenti

Come amministatore creiamo nuovi utenti e gestiamo i loro ruoli
Adesso che abbiamo tutto predisposto iniziamo ad incorporare l'autorizzazione nel template della nostra applicazione


Risorse web:

* [Gestire gli utenti tramite interfaccia CRUD](https://github.com/plataformatec/devise/wiki/How-To:-Manage-users-through-a-CRUD-interface)




## Apriamo il branch "Gestione Utenti"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b gu
~~~~~~~~




## UsersController

non avendo usato lo scaffold per la creazione della tabella users non ho nè le views nè il controller.

Creiamo il controller per la tabella users.

I> Nota che “users” è plurale quando si crea il controller. (al contrario dello scaffold in cui si usa il singolare)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g controller users index
~~~~~~~~

Inizializiamo con la sola azione **index** perché le altre le aggiungiamo di volta in volta.
Avremmo potuto inizializzare tutte e 7 le azioni restfull con ** $ rails g controller users index show new edit create update destroy **




## Un controller di esempio

Creiamoci anche uno scaffold di esempio per aiutarci ad inserire il codice nel nostro controller rispettando le convenzioni rails.
Per i campi possiamo rifarci allo schema del database

{id="01-07-04_01", title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=18}
~~~~~~~~
  create_table "users", force: :cascade do |t|
    t.string "name", default: "", null: false
    t.string "email", default: "", null: false
    t.string "encrypted_password", default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
~~~~~~~~

[Codice 01](#01-07-04_01all)


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold ExampleUser name:string email:string encrypted_password:string remember_created_at:datetime
~~~~~~~~

questo crea il migrate:

{title=".../db/migrate/xxx_create_example_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreateExampleUsers < ActiveRecord::Migration[5.2]
  def change
    create_table :example_users do |t|
      t.string :name
      t.string :email
      t.string :encrypted_password
      t.datetime :remember_created_at

      t.timestamps
    end
  end
end
~~~~~~~~

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

Vediamo che lo schema del database si è aggiornato

{id="01-07-04_02", title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=18}
~~~~~~~~
  create_table "example_users", force: :cascade do |t|
.
.
.
  create_table "users", force: :cascade do |t|
~~~~~~~~

[Codice 02](#01-07-04_02all)

Potevamo evitare di fare il migrate ed eliminarlo perché questa tabella non la useremo. Lo abbiamo fatto solo a scopo didattico.




### Una furbata

invece di crearci lo scaffold di una tabella example_users avremmo potuto lanciare il comando come se stessimo creando la tabella users senza eseguire il "$ rails db:migrate" e cancellando il file di migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold User name:string email:string encrypted_password:string remember_created_at:datetime
~~~~~~~~

in questo modo avremmo avuto tutto già pronto. :)
Però per la didattica di questo libro creiamo il controller User da zero aiutandoci con ExampleUser.




## Implementiamo l'azione index 

Aggiorniamo il controller implementando l'azione index per visualizzare l'elenco di tutti gli utenti

{id="01-07-04_03", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  def index
    @users = User.all
  end
~~~~~~~~

[Codice 03](#01-07-04_03all)




## Creiamo la view index

Creiamo il nuovo file "index.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/index.html.erb" e lo riadattiamo

{id="01-07-04_04", title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<h1>Users</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
~~~~~~~~

[Codice 04](#01-07-04_04all)

Se avessimo voluto tenere tutto organizzato in una sottocartella tipo "views/users/accounts" avremmo dovuto lavorare sul controller e sulla routes come faremo più avanti per authors/posts.




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/users




## Implementiamo l'azione show

Aggiorniamo il controller implementando l'azione show per visualizzare il singolo utente.
Copiamo ed implementiamo la parte di codice per l'azione show, il before_action lo lascio pronto anche per le prossime azioni.

{id="01-07-04_05", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=10}
~~~~~~~~
  # GET /users/1
  # GET /users/1.json
  def show
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end
~~~~~~~~

[Codice 05](#01-07-04_05all)

Per la sola azione user non serviva il before_action con il metodo private. Bastava:

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=off}
~~~~~~~~
  # GET /users/1
  # GET /users/1.json
  def show
      @user = User.find(params[:id])
  end
~~~~~~~~

Ma è utile ed elegante estrarre **@user = User.find(params[:id])** in un metodo private perché questo è chiamato anche da altre azioni (:show, :edit, :update e :destroy)




## Creiamo la view show

Creiamo il nuovo file "show.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/show.html.erb" e lo riadattiamo

{id="01-07-04_06", title=".../app/views/users/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<p>
  <strong>Name:</strong>
  <%= @user.name %>
</p>
~~~~~~~~

[Codice 06](#01-07-04_06all)




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/users/1




## Implementiamo l'azione edit

Aggiorniamo il controller implementando le azioni edit ed update per editare i campi del singolo utente.
Copiamo ed implementiamo la parte di codice per le azioni edit ed update.

{id="01-07-04_07", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show, :edit, :update]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/1/edit
  def edit
  end


  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=40}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :encrypted_password, :remember_created_at)
    end
~~~~~~~~

[Codice 07](#01-07-04_07all)




## Creiamo la view edit

Creiamo i nuovi files "edit.html.erb" e "_form.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto dei files su "views/example_users/..." e lo riadattiamo.

{id="01-07-04_08", title=".../app/views/users/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', user: @user %>
~~~~~~~~

[Codice 08](#01-07-04_08all)


{id="01-07-04_09", title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: user, local: true) do |form| %>

  <div class="field">
    <%= form.label :password %>
    <%= form.text_field :password %>
  </div>

  <div class="field">
    <%= form.label :password_confirmation %>
    <%= form.text_field :password_confirmation %>
  </div>
~~~~~~~~

[Codice 09](#01-07-04_09all)




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/users/1/edit

Con questo form possiamo cambiare il nome e l'email ma non possiamo cambiare la password perché è criptata. O meglio, se cambiamo la password criptata non possiamo più loggarci perché non possiamo risalire alla password in chiaro.




## Implementiamo i campi password e password_confirmation

Devise ci offre la soluzione perché accetta la password passata attraverso i campi **password** e **password_confirmation**
Quindi usiamo questi campi al posto del campo **encrypted_password**

{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=24}
~~~~~~~~
  <div class="field">
    <%= form.label :password %>
    <%= form.text_field :password %>
  </div>

  <div class="field">
    <%= form.label :password_confirmation %>
    <%= form.text_field :password_confirmation %>
  </div>
~~~~~~~~

Ed aggiorniamo la white-list del controller 

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=40}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at)
    end
~~~~~~~~

Adesso L'update funziona per tutti i campi ma abbiamo un problema di sicurezza perché ogni utente può cambiare nome, email e password a tutti gli utenti.
Questo problema di sicurezza lo risolveremo nei prossimi capitoli.




## Implementiamo l'azione new
Aggiorniamo il controller implementando le azioni new e create per creare un nuovo utente.
Copiamo ed implementiamo la parte di codice per le azioni new e create.

{id="01-07-04_10", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/new
  def new
    @user = User.new
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=24}
~~~~~~~~
  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

[Codice 10](#01-07-04_10all)




## Creiamo la view new

Creiamo il nuovo file "new.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto del file su "views/example_users/..." e lo riadattiamo.

{id="01-07-04_11", title=".../app/views/users/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', user: @user %>
~~~~~~~~

[Codice 11](#01-07-04_11all)

Il file "_form.html.erb" lo abbiamo già creato implementando "edit".
In pratica la differenza tra "edit" e "new" è tutta nelle azioni del controller.




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/users/new

Oltre Ann creiamo altri cinque utenti in modo da avere 6 utenti come seguente tabella:

name  | email           | password
------------------------------------------
Ann	  | ann@test.abc    | passworda
Bob	  | bob@test.abc    | passwordb
Carl	| carl@test.abc   | passwordc
David	| david@test.abc  | passwordd
Elvis	| elvis@test.abc  | passworde
flav  | flav@test.abc   | passwordf




## Implementiamo l'azione destroy

Aggiorniamo il controller implementando l'azione destroy per eliminare un utente.
copiamo ed implementiamo la parte di codice per l'azione destroy.

{id="01-07-04_12", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show, :edit, :update, :destroy]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy
    respond_to do |format|
      format.html { redirect_to users_url, notice: 'User was successfully destroyed.' }
      format.json { head :no_content }
    end
  end
~~~~~~~~

[Codice 12](#01-07-04_12all)




## Verifichiamo il link "destroy" nella view index

{title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=25}
~~~~~~~~
        <td><%= link_to 'Destroy', user, method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~




### Verifichiamo preview

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

* https://mycloud9path.amazonaws.com/users

Eliminiamo l'utente "flav" (id: 6)




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Implement views to manage users"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku gu:master
$ heroku run rails db:migrate
~~~~~~~~

popoliamo con i 6 utenti anche il database remoto su heroku

Lo potremmo fare da console con

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rails c
~~~~~~~~

Ma visto che abbiamo implementato l'interfaccia grafica lo facciamo a partire dall'URL:

* https://myapp-1-blabla.herokuapp.com/users




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge gu
$ git branch -d gu
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~




## Il codice del capitolo




[Codice 01](#01-07-04_01)

{id="01-07-04_01all", title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
    t.string "name", default: "", null: false
    t.string "email", default: "", null: false
    t.string "encrypted_password", default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
~~~~~~~~




[Codice 02](#01-07-04_02)

{id="01-07-04_02all", title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
# This file is auto-generated from the current state of the database. Instead
# of editing this file, please use the migrations feature of Active Record to
# incrementally modify your database, and then regenerate this schema definition.
#
# Note that this schema.rb definition is the authoritative source for your
# database schema. If you need to create the application database on another
# system, you should be using db:schema:load, not running all the migrations
# from scratch. The latter is a flawed and unsustainable approach (the more migrations
# you'll amass, the slower it'll run and the greater likelihood for issues).
#
# It's strongly recommended that you check this file into your version control system.

ActiveRecord::Schema.define(version: 2019_01_05_225934) do

  # These are extensions that must be enabled in order to support this database
  enable_extension "plpgsql"

  create_table "example_users", force: :cascade do |t|
    t.string "name"
    t.string "email"
    t.string "encrypted_password"
    t.datetime "remember_created_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "users", force: :cascade do |t|
    t.string "name", default: "", null: false
    t.string "email", default: "", null: false
    t.string "encrypted_password", default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["email"], name: "index_users_on_email", unique: true
    t.index ["reset_password_token"], name: "index_users_on_reset_password_token", unique: true
  end

end
~~~~~~~~





[Codice 03](#01-07-04_03)

{id="01-07-04_03all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
class UsersController < ApplicationController

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

end
~~~~~~~~





[Codice 04](#01-07-04_04)

{id="01-07-04_04all", title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<h1>Users</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
      <th>Encrypted password</th>
      <th>Remember created at</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @users.each do |user| %>
      <tr>
        <td><%= user.name %></td>
        <td><%= user.email %></td>
        <td><%= user.encrypted_password %></td>
        <td><%= user.remember_created_at %></td>
        <td><%= link_to 'Show', user %></td>
        <td><%= link_to 'Edit', edit_user_path(user) %></td>
        <td><%= link_to 'Destroy', user, method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New User', new_user_path %>
~~~~~~~~




[Codice 05](#01-07-04_05)

{id="01-07-04_05all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class UsersController < ApplicationController
  before_action :set_example_user, only: [:show]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end

end
~~~~~~~~




[Codice 06](#01-07-04_06)

{id="01-07-04_06all", title=".../app/views/users/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<p>
  <strong>Name:</strong>
  <%= @user.name %>
</p>

<p>
  <strong>Email:</strong>
  <%= @user.email %>
</p>

<p>
  <strong>Encrypted password:</strong>
  <%= @user.encrypted_password %>
</p>

<p>
  <strong>Remember created at:</strong>
  <%= @user.remember_created_at %>
</p>

<%= link_to 'Edit', edit_user_path(@user) %> |
<%= link_to 'Back', users_path %>
~~~~~~~~




[Codice 07](#01-07-04_07)

{id="01-07-04_07all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class UsersController < ApplicationController
  before_action :set_user, only: [:show, :edit]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  # GET /users/1/edit
  def edit
  end


  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :encrypted_password, :remember_created_at)
    end

end
~~~~~~~~





[Codice 08](#01-07-04_08)

{id="01-07-04_08all", title=".../app/views/users/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<h1>Editing User</h1>

<%= render 'form', user: @user %>

<%= link_to 'Show', @user %> |
<%= link_to 'Back', users_path %>
~~~~~~~~





[Codice 09](#01-07-04_09)

{id="01-07-04_09all", title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: user, local: true) do |form| %>
  <% if user.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(user.errors.count, "error") %> prohibited this example_user from being saved:</h2>

      <ul>
      <% user.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= form.label :name %>
    <%= form.text_field :name %>
  </div>

  <div class="field">
    <%= form.label :email %>
    <%= form.text_field :email %>
  </div>

  <div class="field">
    <%= form.label :encrypted_password %>
    <%= form.text_field :encrypted_password %>
  </div>

  <div class="actions">
    <%= form.submit %>
  </div>
<% end %>
~~~~~~~~





[Codice 10](#01-07-04_10)

{id="01-07-04_10all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class UsersController < ApplicationController
  before_action :set_user, only: [:show, :edit, :update]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  # GET /users/new
  def new
    @user = User.new
  end
  
  # GET /users/1/edit
  def edit
  end

  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at)
    end

end
~~~~~~~~





[Codice 11](#01-07-04_11)

{id="01-07-04_11all", title=".../app/views/users/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<h1>New User</h1>

<%= render 'form', user: @user %>

<%= link_to 'Back', users_path %>
~~~~~~~~





[Codice 12](#01-07-04_12)

{id="01-07-04_12all", title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class UsersController < ApplicationController
  before_action :set_user, only: [:show, :edit, :update, :destroy]

  # GET /users
  # GET /users.json
  def index
    @users = User.all
  end

  # GET /users/1
  # GET /users/1.json
  def show
  end

  # GET /users/new
  def new
    @user = User.new
  end
  
  # GET /users/1/edit
  def edit
  end

  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy
    respond_to do |format|
      format.html { redirect_to users_url, notice: 'User was successfully destroyed.' }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at)
    end

end
~~~~~~~~
