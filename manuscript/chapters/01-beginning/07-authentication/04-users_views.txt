# Implementiamo la gestione degli utenti




## Apriamo il branch "Gestione Utenti"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b gu
~~~~~~~~




## UsersController

non avendo usato lo scaffold per la creazione della tabella users non ho nè le views nè il controller.

Creiamo il controller per la tabella users.

I> Nota che “users” è plurale quando si crea il controller. (al contrario dello scaffold in cui si usa il singolare)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g controller users index
~~~~~~~~

Inizializiamo con la sola azione **index** perché le altre le aggiungiamo di volta in volta.
Avremmo potuto inizializzare tutte e 7 le azioni restfull con ** $ rails g controller users index show new edit create update destroy **




## Un controller di esempio

Creiamoci anche uno scaffold di esempio per aiutarci ad inserire il codice nel nostro controller rispettando le convenzioni rails.
Per i campi possiamo rifarci allo schema del database

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=19}
~~~~~~~~
    t.string "name"
    t.string "email", default: "", null: false
    t.string "encrypted_password", default: "", null: false
    t.string "reset_password_token"
    t.datetime "reset_password_sent_at"
    t.datetime "remember_created_at"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
~~~~~~~~

[cod. a](beginning-authentication-04a-db-schema.rb)


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold ExampleUser name:string email:string encrypted_password:string remember_created_at:datetime
~~~~~~~~

questo crea il migrate:

{title=".../db/migrate/xxx_create_example_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
    create_table :example_users do |t|
      t.string :name
      t.string :email
      t.string :encrypted_password
      t.datetime :remember_created_at

      t.timestamps
    end
~~~~~~~~

[cod. b](beginning-authentication-04b-db-migrate-xxx_create_example_users.rb)

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

Vediamo che lo schema del database si è aggiornato

[cod. c](beginning-authentication-04c-db-schema.rb)




### Una furbata

invece di crearci lo scaffold di una tabella example_users avremmo potuto lanciare il comando come se stessimo creando la tabella users senza eseguire il "$ rails db:migrate" e cancellando il file di migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold User name:string email:string encrypted_password:string remember_created_at:datetime
~~~~~~~~

in questo modo avremmo avuto tutto già pronto. :)
Però per la didattica di questo libro creiamo il controller User da zero aiutandoci con ExampleUser.




## Implementiamo l'azione index 

Aggiorniamo il controller implementando l'azione index per visualizzare l'elenco di tutti gli utenti

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  def index
    @users = User.all
  end
~~~~~~~~

[cod. d](beginning-authentication-04d-controllers-users_controller.rb)




## Creiamo la view index

Creiamo il nuovo file "index.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/index.html.erb" e lo riadattiamo

{title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<h1>Users</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Email</th>
~~~~~~~~

[cod. e](beginning-authentication-04e-views-users-index.html.erb)

Se avessimo voluto tenere tutto organizzato in una sottocartella tipo "views/users/accounts" avremmo dovuto lavorare sul controller e sulla routes come faremo più avanti per authors/posts.




## Verifichiamo che tutto funziona

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

https://mycloud9path.amazonaws.com/users




## Implementiamo l'azione show

Aggiorniamo il controller implementando l'azione show per visualizzare il singolo utente.
Copiamo ed implementiamo la parte di codice per l'azione show, il before_action lo lascio pronto anche per le prossime azioni.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=10}
~~~~~~~~
  # GET /users/1
  # GET /users/1.json
  def show
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_user
      @user = User.find(params[:id])
    end
~~~~~~~~

[cod. f](beginning-authentication-04f-controllers-users_controller.rb)

Per la sola azione user non serviva il before_action con il metodo private. Bastava:

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=off}
~~~~~~~~
  # GET /users/1
  # GET /users/1.json
  def show
      @user = User.find(params[:id])
  end
~~~~~~~~

Ma è utile ed elegante estrarre **@user = User.find(params[:id])** in un metodo private perché questo è chiamato anche da altre azioni (:show, :edit, :update e :destroy)




## Creiamo la view show

Creiamo il nuovo file "show.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto di "views/example_users/show.html.erb" e lo riadattiamo

{title=".../app/views/users/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<p>
  <strong>Name:</strong>
  <%= @user.name %>
</p>
~~~~~~~~

[cod. g](beginning-authentication-04g-views-users-show.html.erb)



## Verifichiamo che tutto funziona

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

https://mycloud9path.amazonaws.com/users/1




## Implementiamo l'azione edit

Aggiorniamo il controller implementando le azioni edit ed update per editare i campi del singolo utente.
Copiamo ed implementiamo la parte di codice per le azioni edit ed update.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show, :edit, :update]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/1/edit
  def edit
  end


  # PATCH/PUT /users/1
  # PATCH/PUT /users/1.json
  def update
    respond_to do |format|
      if @user.update(user_params)
        format.html { redirect_to @user, notice: 'User was successfully updated.' }
        format.json { render :show, status: :ok, location: @user }
      else
        format.html { render :edit }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=40}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :encrypted_password, :remember_created_at)
    end
~~~~~~~~

[cod. h](beginning-authentication-04h-controllers-users_controller.rb)



## Creiamo la view edit

Creiamo i nuovi files "edit.html.erb" e "_form.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto dei files su "views/example_users/..." e lo riadattiamo.

{title=".../app/views/users/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', user: @user %>
~~~~~~~~

[cod. i](beginning-authentication-04i-views-users-edit.html.erb)


{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: user, local: true) do |form| %>

  <div class="field">
    <%= form.label :password %>
    <%= form.text_field :password %>
  </div>

  <div class="field">
    <%= form.label :password_confirmation %>
    <%= form.text_field :password_confirmation %>
  </div>
~~~~~~~~

[cod. j](beginning-authentication-04j-views-users-_form.html.erb)




## Verifichiamo che tutto funziona

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

https://mycloud9path.amazonaws.com/users/1/edit

Con questo form possiamo cambiare il nome e l'email ma non possiamo cambiare la password perché è criptata. O meglio, se cambiamo la password criptata non possiamo più loggarci perché non possiamo risalire alla password in chiaro.




## Implementiamo i campi password e password_confirmation

Devise ci offre la soluzione perché accetta la password passata attraverso i campi **password** e **password_confirmation**
Quindi usiamo questi campi al posto del campo **encrypted_password**

{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=24}
~~~~~~~~
  <div class="field">
    <%= form.label :password %>
    <%= form.text_field :password %>
  </div>

  <div class="field">
    <%= form.label :password_confirmation %>
    <%= form.text_field :password_confirmation %>
  </div>
~~~~~~~~

Ed aggiorniamo la white-list del controller 

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=40}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at)
    end
~~~~~~~~

Adesso L'update funziona per tutti i campi ma abbiamo un problema di sicurezza perché ogni utente può cambiare nome, email e password a tutti gli utenti.
Questo problema di sicurezza lo risolveremo nei prossimi capitoli.




## Implementiamo l'azione new
Aggiorniamo il controller implementando le azioni new e create per creare un nuovo utente.
Copiamo ed implementiamo la parte di codice per le azioni new e create.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # GET /users/new
  def new
    @user = User.new
  end
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=24}
~~~~~~~~
  # POST /users
  # POST /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        format.html { redirect_to @user, notice: 'User was successfully created.' }
        format.json { render :show, status: :created, location: @user }
      else
        format.html { render :new }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
~~~~~~~~

[cod. k](beginning-authentication-04k-controllers-users_controller.rb)




## Creiamo la view new

Creiamo il nuovo file "new.html.erb" dentro la cartella "views/users". Ci copiamo il contenuto del file su "views/example_users/..." e lo riadattiamo.

{title=".../app/views/users/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', user: @user %>
~~~~~~~~

[cod. l](beginning-authentication-04l-views-users-new.html.erb)

Il file "_form.html.erb" lo abbiamo già creato implementando "edit".
In pratica la differenza tra "edit" e "new" è tutta nelle azioni del controller.




## Verifichiamo che tutto funziona

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

https://mycloud9path.amazonaws.com/users/new

Creiamo 6 utenti
name  | email           | password
------------------------------------------
Ann	  | ann@test.abc    | passworda
Bob	  | bob@test.abc    | passwordb
Carl	| carl@test.abc   | passwordc
David	| david@test.abc  | passwordd
Elvis	| elvis@test.abc  | passworde
flav  | flav@test.abc   | passwordf




## Implementiamo l'azione destroy

Aggiorniamo il controller implementando l'azione destroy per eliminare un utente.
copiamo ed implementiamo la parte di codice per l'azione destroy.

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=2}
~~~~~~~~
  before_action :set_user, only: [:show, :edit, :update, :destroy]
~~~~~~~~

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=15}
~~~~~~~~
  # DELETE /users/1
  # DELETE /users/1.json
  def destroy
    @user.destroy
    respond_to do |format|
      format.html { redirect_to users_url, notice: 'User was successfully destroyed.' }
      format.json { head :no_content }
    end
  end
~~~~~~~~

[cod. m](beginning-authentication-04m-controllers-users_controller.rb)




## Verifichiamo il link "destroy" nella view index

{title=".../app/views/users/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=25}
~~~~~~~~
        <td><%= link_to 'Destroy', user, method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~




## Verifichiamo che tutto funziona

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~

https://mycloud9path.amazonaws.com/users

Eliminiamo l'utente "flav" (id: 6)




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Implement views to manage users"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku gu:master
$ heroku run rails db:migrate
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge gu
$ git branch -d gu
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
