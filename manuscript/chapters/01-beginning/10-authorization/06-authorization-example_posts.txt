# Implementiamo le autorizzazioni per example_posts

In questo capitolo inseriamo meno passaggi e meno spiegazioni rispetto al capitolo precedente.



## Apriamo il branch "Authorization ExamplePost"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b aep
~~~~~~~~




## Aggiungiamo policy per ExamplePost

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g pundit:policy ExamplePost
~~~~~~~~

{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ExamplePostPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      scope.all
    end
  end
end
~~~~~~~~




## Implementiamo tutte le policies per tutte le azioni di example_posts

Vediamo uno schema della logica delle autorizzazioni

Legenda:
 * per "records" si intendono gli "articoli di esempio" (example_posts)
 * per "propri records" si intendono gli "articoli di esempio di cui l'utente è proprietario". Ossia dove ha una relazione uno-a-molti.

index
 * Utente non loggato           : autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

show
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

new/create
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato SOLO sui propri records


edit/update
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

destroy
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records


{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  def index?
    true
  end

  def show?
    if @user.present?
      true
    else
      false
    end
  end
  
  def create?
    if @user.present?
      @user.author? or @user.moderator? or @user.admin?
    else
      false
    end
  end
  
  def update?
    if @user.present?
      if @user.user?
        false
      else
        @user.id == @record.user_id or @user.admin?
      end
    else
      false
    end
  end

  def destroy?
    if @user.present?
      @user.id == @record.user_id or @user.moderator? or @user.admin?
    else
      false
    end
  end
~~~~~~~~

Facciamo dei piccoli refactoring

{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  def show?
    @user.present?
  end
~~~~~~~~

ottengo già true o false e quindi non mi serve un ciclo if...else...end

{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  def update?
    if @user.present?
      @user.id == @record.user_id or @user.admin?
    else
      false
    end
  end
~~~~~~~~

Questo autorizzerebbe l'user a modificare i suoi propri record ma non potendoli creare non ha record da modificare.

[cod. a](beginning-authorization-06a-policies-example_post_policy.rb)




## Implementiamo nel controller

{title=".../app/controllers/example_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=6}
~~~~~~~~
  def index
    @example_posts = ExamplePost.all
    authorize @example_posts
~~~~~~~~

{title=".../app/controllers/example_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=17}
~~~~~~~~
  def new
    @example_post = ExamplePost.new
    authorize @example_post
~~~~~~~~

{title=".../app/controllers/example_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=28}
~~~~~~~~
  def create
    @example_post = ExamplePost.new(example_post_params)
    authorize @example_post
~~~~~~~~

Per le azioni [:show, :edit, :update, :destroy], che chiamano la funzione "set_user" con il before_action, inserisco l'autorizzazione direttamente sulla funzione "set_user"

{title=".../app/controllers/example_posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=71}
~~~~~~~~
    def set_example_post
      @example_post = ExamplePost.find(params[:id])
      authorize @example_post
~~~~~~~~

[cod. b](beginning-authorization-06b-controllers-example_posts_controller.rb)




## verifichiamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s
~~~~~~~~




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "add pundit authorization on all actions of example_post"
~~~~~~~~




## Un refactoring sulla logica della policy

riportiamo la gestione della logica della policy ad una situazione simile schema della logica delle autorizzazioni: 

index
 * Utente non loggato           : autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

show
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato su tutti i records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

new/create
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato SOLO sui propri records


edit/update
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato SOLO sui propri records
 * Utente con ruolo "admin"     : autorizzato su tutti i records

destroy
 * Utente non loggato           : NON autorizzato su tutti i records
 * Utente con ruolo "user"      : NON autorizzato su tutti i records
 * Utente con ruolo "author"    : autorizzato SOLO sui propri records
 * Utente con ruolo "moderator" : autorizzato su tutti i records
 * Utente con ruolo "admin"     : autorizzato su tutti i records


{title=".../app/policies/example_post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  def index?
    if @user.present?
      case @user.role
      when 'user'
        true
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      true
    end
  end

  def show?
    if @user.present?
      case @user.role
      when 'user'
        true
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
  
  def create?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        true
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
  
  def update?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        @user.id == @record.user_id
      when 'moderator'
        @user.id == @record.user_id
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end

  def destroy?
    if @user.present?
      case @user.role
      when 'user'
        false
      when 'author'
        @user.id == @record.user_id
      when 'moderator'
        true
      when 'admin'
        true
      else
        false #se arrivo qui c'è un errore quindi non autorizzo
      end
    else
      false
    end
  end
~~~~~~~~

In questo modo mi è molto più chiaro capire la logica delle autorizzazioni.

[cod. c](beginning-authorization-06c-policies-example_post_policy.rb)




## verifichiamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
~~~~~~~~




## aggiorniamo git 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Refactor policies conditions like the logical schema"
~~~~~~~~




## Publichiamo su heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku aep:master
$ heroku run rake db:migrate
~~~~~~~~

I> Lato produzione su heroku c'è un database indipendente da quello di sviluppo quindi risulta vuoto.

per popolare il database di heroku basta aprire la console con il comando:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rails c
~~~~~~~~

E rieseguire i passi già fatti nel paragrafo precedentemente



## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge aep
$ git branch -d aep
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
