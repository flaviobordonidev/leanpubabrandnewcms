# Roles - enum

Questo approccio è semplice e permette di avere più ruoli fissi (es: user, vip, admin) o (es: silver, gold, platinum, diamond).
Questo livello permette di gestire più del 90% delle esigenze delle applicazioni web. Usato con pundit e devise riesce a coprire quasi tutte le esigenze di autorizzazione.
Per questo motivo rolify è stato messo su una sezione distinta, proprio perché è una gemma che, quasi sempre, possiamo evitare di installare.

Aggiungiamo i vari ruoli utilizzando un attributo (role attribute) e non un intero modello.
Questo vuol dire aggiungere una colonna "role" di tipo integer sulla tabella **users** e dichiarare l'uso di **enum** sul model User.

Volendo usare "rolify" possiamo saltare direttamente alla sezione 12-rolification


Risorse web:

* [articolo lungo vai al paragrafo Implementing Roles - Enum Roles](http://railsapps.github.io/rails-authorization.html)
* [esempio roles](https://github.com/RailsApps/rails-devise-roles/blob/master/app/views/users/_user.html.erb)
* [esempio pundit](https://github.com/RailsApps/rails-devise-pundit/blob/master/app/views/users/_user.html.erb)

* [Ruby on Rails - how to create perfect enum in 5 steps](https://naturaily.com/blog/ruby-on-rails-enum)
* [Ruby on Rails 5.2.0 - Module - ActiveRecord::Enum](https://api.rubyonrails.org/v5.2.0/classes/ActiveRecord/Enum.html)

* [Ruby on Rails: Customize the devise user (Screencast #1)](https://www.youtube.com/watch?v=5inpxIHKhkE)
* https://github.com/plataformatec/devise
* https://github.com/plataformatec/devise/wiki/How-To:-Allow-users-to-edit-their-password




## Apriamo il branch "Roles Enum"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b re
~~~~~~~~




## Aggiungiamo il campo roles:enum alla tabella users

nel db postgresql si possono implementare dei campi "enum" ma nel nostro caso restiamo con il semplice "integer" nel db.

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_role_to_users role:integer
~~~~~~~~

Modifichiamo il migrate aggiungendo un default e l'indice per velocizzare queries che usano "role"

{title=".../db/migrate/xxx_add_role_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddRoleToUsers < ActiveRecord::Migration[5.2]
  def change
    add_column :users, :role, :integer, default: 0
    add_index :users, :role, unique: false
  end
end
~~~~~~~~

[cod. a](beginning-authorization-03a-xxx_add_role_to_users.rb)

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

ed otteniamo le seguenti modifiche alla tabella "users"

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=52}
~~~~~~~~
    t.integer "role", default: 0
~~~~~~~~

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=55}
~~~~~~~~
    t.index ["role"], name: "index_users_on_role"
~~~~~~~~

[cod. b](beginning-authorization-03b-db-schema.rb)

Avremmo potuto aggiungere l'indice anche in un secondo momemento

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_index_to_role_to_users
~~~~~~~~

{title=".../db/migrate/xxx_add_index_to_role_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddIndexToRoleToUsers < ActiveRecord::Migration
  def change
    add_index :users, :role, unique: false
  end
end
~~~~~~~~




## Aggiorniamo il Model implementando ENUM

{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  #enum role: [:user, :admin, :moderator, :author]
  enum role: {user: 0, admin: 1, moderator:2, author:3}
~~~~~~~~

Se non avessimo voluto usare il default lato database con **default: 0** potevamo farlo sul model così:  
  
{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  after_initialize :set_default_role, :if => :new_record?

  def set_default_role
    self.role ||= :user
  end
~~~~~~~~

ma lato database è più pulito e più prestazionale.





## Assegnamo un ruolo ai nostri utenti da console rails


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
~~~~~~~~

verifichiamo tutti i ruoli presenti nella colonna "role" assegnata ad enum.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.roles 
 => {"user"=>0, "admin"=>1, "moderator"=>2, "author"=>3} 
~~~~~~~~

verifichiamo che tutti gli utenti hanno il campo della colonna role con il valore di default "0", che per enum corrisponde al valore "user".

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.all
  User Load (0.3ms)  SELECT  "users".* FROM "users" LIMIT $1  [["LIMIT", 11]]
 => #<ActiveRecord::Relation [#<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2018-12-12 13:05:10", updated_at: "2018-12-26 12:51:27", role: "user">, #<User id: 2, name: "Bob", email: "bob@test.abc", created_at: "2018-12-26 14:29:26", updated_at: "2018-12-26 14:29:26", role: "user">, #<User id: 3, name: "Carl", email: "carl@test.abc", created_at: "2018-12-26 14:30:56", updated_at: "2018-12-26 14:30:56", role: "user">, #<User id: 4, name: "David", email: "david@test.abc", created_at: "2018-12-26 14:31:32", updated_at: "2018-12-26 14:31:32", role: "user">, #<User id: 5, name: "Elvis", email: "elvis@test.abc", created_at: "2018-12-26 14:32:04", updated_at: "2018-12-26 23:25:49", role: "user">, #<User id: 7, name: "flavio", email: "flavio@test.abc", created_at: "2018-12-26 14:50:20", updated_at: "2018-12-26 23:25:58", role: "user">]> 
~~~~~~~~

rendiamo il primo utente amministratore

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.first.admin!
  User Load (0.3ms)  SELECT  "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT $1  [["LIMIT", 1]]
   (0.2ms)  BEGIN
  User Update (0.5ms)  UPDATE "users" SET "role" = $1, "updated_at" = $2 WHERE "users"."id" = $3  [["role", 1], ["updated_at", "2018-12-28 00:15:00.861440"], ["id", 1]]
   (0.7ms)  COMMIT
 => true 

# Oppure

> User.first.update(role: :admin)
  User Update (0.5ms)  UPDATE ...
 => true 

# Oppure

> u= User.first 
> u.role = :admin 
> u.save 
  User Update (0.5ms)  UPDATE ...
 => true 
~~~~~~~~

verifichiamo che ruolo hanno il primo ed il secondo utente

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.first.admin?
 => true 

> User.second.admin? 
 => false 

> User.first.role
 => "admin" 

> User.second.role
 => "user" 
~~~~~~~~

prendiamo una lista di tutti gli :admin

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.admin
 => #<ActiveRecord::Relation [#<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2018-12-12 13:05:10", updated_at: "2018-12-28 00:15:00", role: "admin">]> 
~~~~~~~~

prendiamo una lista di tutti gli :user

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.user
 => #<ActiveRecord::Relation [#<User id: 2, name: "Bob", email: "bob@test.abc", created_at: "2018-12-26 14:29:26", updated_at: "2018-12-26 14:29:26", role: "user">, #<User id: 3, name: "Carl", email: "carl@test.abc", created_at: "2018-12-26 14:30:56", updated_at: "2018-12-26 14:30:56", role: "user">, #<User id: 4, name: "David", email: "david@test.abc", created_at: "2018-12-26 14:31:32", updated_at: "2018-12-26 14:31:32", role: "user">, #<User id: 5, name: "Elvis", email: "elvis@test.abc", created_at: "2018-12-26 14:32:04", updated_at: "2018-12-26 23:25:49", role: "user">, #<User id: 7, name: "flavio", email: "flavio@test.abc", created_at: "2018-12-26 14:50:20", updated_at: "2018-12-26 23:25:58", role: "user">]>
~~~~~~~~

prendiamo una lista di tutti i :moderator

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.moderator
 => #<ActiveRecord::Relation []> 
~~~~~~~~

usciamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
>exit
~~~~~~~~




## Attiviamo la white list

Invece di cambiare i ruoli da console adesso li cambiamo sulla nostra view.
Abbiamo un piccolo problema. Devise non è come lo scaffold. Non ci crea già le azioni sul controller e le views.

Per poter passare i parametri attraverso le views, o meglio il sumbit del form, dobbiamo inserirli nella white list del controller. Una procedura detta "Strong_params" o "mass-assignment". Ma questo non è così facile su Devise perché di default ci nasconde tutto.

Abbiamo già visualizzato i controllers e le views di devise-users nei capitoli precedenti.
Possiamo passare i parametri in due modi:

1. Usando il controller application (metodo raccomandato dalla Plataformatec creatrice di Devise)
2. Usando il controller user/registration_controller ma in questo caso dobbiamo dichiararlo nella routes




### 1. Il metodo raccomandato da plataformatec. Il metodo Lazy way.

Mettiamo nella whitelist la colonna :role

{title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_in, keys: [:role])
    devise_parameter_sanitizer.permit(:sign_up, keys: [:role])
    devise_parameter_sanitizer.permit(:account_update, keys: [:role])
  end
end
~~~~~~~~

[cod. c](beginning-authorization-03c-application_controller.rb)

I loro nomi e parametri di default permessi sono:

* sign_in (Devise::SessionsController#create) - Permette solo le chiavi di autenticazione come il campo :email
* sign_up (Devise::RegistrationsController#create) - Permette le chiavi di autenticazione più i campi :password e :password_confirmation
* account_update (Devise::RegistrationsController#update) - Permette le chiavi di autenticazione più i campi :password, :password_confirmation e :current_password


Inoltre mettiamo il campo :role nella whitelist di users_controller

{title=".../app/controllers/users_controller.rb", lang=ruby, line-numbers=on, starting-line-number=83}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def user_params
      params.require(:user).permit(:name, :email, :password, :password_confirmation, :remember_created_at, :role)
    end
~~~~~~~~

[cod. d](beginning-authorization-03d-users_controller.rb)




### 2. Questa alternativa è una bozza da sistemare meglio
    
{title=".../app/controllers/users/registrations_controller.rb", lang=ruby, line-numbers=on, starting-line-number=11}
~~~~~~~~
class RegistrationsController < Devise::RegistrationsController

  ...

  private

  def sign_up_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation)
  end

  def account_update_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation, :current_password)
  end
end
~~~~~~~~

Aggiungiamo instradamento users/registrations per devise

{title=".../app/config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=8}
~~~~~~~~
  devise_for :users, controllers: {sessions: 'users/sessions', registration: 'users/registration'}, path: '', path_names: {sign_in: 'login'}
~~~~~~~~




## Aggiorniamo la view

Aggiungiamo un selettore per permettere di cambiare ruolo

{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
~~~~~~~~
  <div class="field">    
    <%= form.label :role %>
    <%#= form.text_field :role %>
    <%= form.select(:role, User.roles.keys.map {|role| [role.titleize,role]}) %>
  </div>
~~~~~~~~

[cod. d](beginning-authorization-03d-views-users-_form.html.erb)

Attenzione: deve essere attivo solo uno dei due campi: "form.text_field :role" o "form.select(:role...". Se attiviamo entrambi i campi verrà passato come params solo il valore dell'ultimo campo perché hanno lo stesso nome.

I> Per approfondimenti vedi sezione rails_references/data_types/select-collection_select




## Implementiamo le autorizzazioni

nel prossimo capitolo finalmente attiviamo la sicurezza implementando le autorizzazioni alle varie azioni.




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add role:enum to table users"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku re:master
$ heroku run rails db:migrate
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge re
$ git branch -d re
~~~~~~~~




## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
