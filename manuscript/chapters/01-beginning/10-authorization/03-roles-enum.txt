# Roles - enum

Questo approccio è semplice e permette di avere più ruoli fissi (es: user, vip, admin) o (es: silver, gold, platinum, diamond).
Questo livello permette di gestire più del 90% delle esigenze delle applicazioni web. Usato con pundit e devise riesce a coprire quasi tutte le esigenze di autorizzazione.
Per questo motivo rolify è stato messo su una sezione distinta, proprio perché è una gemma che, quasi sempre, possiamo evitare di installare.

Aggiungiamo i vari ruoli utilizzando un attributo (role attribute) e non un intero modello.
Questo vuol dire aggiungere una colonna "role" di tipo integer sulla tabella **users** e dichiarare l'uso di **enum** sul model User.

Volendo usare "rolify" possiamo saltare direttamente alla sezione 12-rolification


Risorse web:

* [articolo lungo vai al paragrafo Implementing Roles - Enum Roles](http://railsapps.github.io/rails-authorization.html)
* [esempio roles](https://github.com/RailsApps/rails-devise-roles/blob/master/app/views/users/_user.html.erb)
* [esempio pundit](https://github.com/RailsApps/rails-devise-pundit/blob/master/app/views/users/_user.html.erb)

* [Ruby on Rails - how to create perfect enum in 5 steps](https://naturaily.com/blog/ruby-on-rails-enum)
* [Ruby on Rails 5.2.0 - Module - ActiveRecord::Enum](https://api.rubyonrails.org/v5.2.0/classes/ActiveRecord/Enum.html)

* [Ruby on Rails: Customize the devise user (Screencast #1)](https://www.youtube.com/watch?v=5inpxIHKhkE)
* https://github.com/plataformatec/devise
    



## Apriamo il branch "Roles Enum"

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b re
~~~~~~~~




## Aggiungiamo il campo roles:enum alla tabella users

nel db postgresql si possono implementare dei campi "enum" ma nel nostro caso restiamo con il semplice "integer" nel db.

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_role_to_users role:integer
~~~~~~~~

Modifichiamo il migrate aggiungendo un default e l'indice per velocizzare queries che usano "role"

{title=".../db/migrate/xxx_add_role_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddRoleToUsers < ActiveRecord::Migration[5.2]
  def change
    add_column :users, :role, :integer, default: 0
    add_index :users, :role, unique: false
  end
end
~~~~~~~~

[cod. a](beginning-authorization-03a-xxx_add_role_to_users.rb)

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

ed otteniamo le seguenti modifiche alla tabella "users"

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=52}
~~~~~~~~
    t.integer "role", default: 0
~~~~~~~~

{title=".../db/schema.rb", lang=ruby, line-numbers=on, starting-line-number=55}
~~~~~~~~
    t.index ["role"], name: "index_users_on_role"
~~~~~~~~

[cod. b](beginning-authorization-03b-db-schema.rb)

Avremmo potuto aggiungere l'indice anche in un secondo momemento

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_index_to_role_to_users
~~~~~~~~

{title=".../db/migrate/xxx_add_index_to_role_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddIndexToRoleToUsers < ActiveRecord::Migration
  def change
    add_index :users, :role, unique: false
  end
end
~~~~~~~~




## Aggiorniamo il Model implementando ENUM

{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  #enum role: [:user, :admin, :moderator, :author]
  enum role: {user: 0, admin: 1, moderator:2, author:3}
~~~~~~~~

Se non avessimo voluto usare il default lato database con **default: 0** potevamo farlo sul model così:  
  
{title=".../models/user.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  after_initialize :set_default_role, :if => :new_record?

  def set_default_role
    self.role ||= :user
  end
~~~~~~~~

ma lato database è più pulito e più prestazionale.





## Assegnamo un ruolo ai nostri utenti da console rails


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
~~~~~~~~

verifichiamo tutti i ruoli presenti nella colonna "role" assegnata ad enum.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.roles 
 => {"user"=>0, "admin"=>1, "moderator"=>2, "author"=>3} 
~~~~~~~~

verifichiamo che tutti gli utenti hanno il campo della colonna role con il valore di default "0", che per enum corrisponde al valore "user".

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.all
  User Load (0.3ms)  SELECT  "users".* FROM "users" LIMIT $1  [["LIMIT", 11]]
 => #<ActiveRecord::Relation [#<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2018-12-12 13:05:10", updated_at: "2018-12-26 12:51:27", role: "user">, #<User id: 2, name: "Bob", email: "bob@test.abc", created_at: "2018-12-26 14:29:26", updated_at: "2018-12-26 14:29:26", role: "user">, #<User id: 3, name: "Carl", email: "carl@test.abc", created_at: "2018-12-26 14:30:56", updated_at: "2018-12-26 14:30:56", role: "user">, #<User id: 4, name: "David", email: "david@test.abc", created_at: "2018-12-26 14:31:32", updated_at: "2018-12-26 14:31:32", role: "user">, #<User id: 5, name: "Elvis", email: "elvis@test.abc", created_at: "2018-12-26 14:32:04", updated_at: "2018-12-26 23:25:49", role: "user">, #<User id: 7, name: "flavio", email: "flavio@test.abc", created_at: "2018-12-26 14:50:20", updated_at: "2018-12-26 23:25:58", role: "user">]> 
~~~~~~~~

rendiamo il primo utente amministratore

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.first.admin!
  User Load (0.3ms)  SELECT  "users".* FROM "users" ORDER BY "users"."id" ASC LIMIT $1  [["LIMIT", 1]]
   (0.2ms)  BEGIN
  User Update (0.5ms)  UPDATE "users" SET "role" = $1, "updated_at" = $2 WHERE "users"."id" = $3  [["role", 1], ["updated_at", "2018-12-28 00:15:00.861440"], ["id", 1]]
   (0.7ms)  COMMIT
 => true 

# Oppure

> User.first.update(role: :admin)
  User Update (0.5ms)  UPDATE ...
 => true 

# Oppure

> u= User.first 
> u.role = :admin 
> u.save 
  User Update (0.5ms)  UPDATE ...
 => true 
~~~~~~~~

verifichiamo che ruolo hanno il primo ed il secondo utente

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.first.admin?
 => true 

> User.second.admin? 
 => false 

> User.first.role
 => "admin" 

> User.second.role
 => "user" 
~~~~~~~~

prendiamo una lista di tutti gli :admin

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.admin
 => #<ActiveRecord::Relation [#<User id: 1, name: "Ann", email: "ann@test.abc", created_at: "2018-12-12 13:05:10", updated_at: "2018-12-28 00:15:00", role: "admin">]> 
~~~~~~~~

prendiamo una lista di tutti gli :user

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.user
 => #<ActiveRecord::Relation [#<User id: 2, name: "Bob", email: "bob@test.abc", created_at: "2018-12-26 14:29:26", updated_at: "2018-12-26 14:29:26", role: "user">, #<User id: 3, name: "Carl", email: "carl@test.abc", created_at: "2018-12-26 14:30:56", updated_at: "2018-12-26 14:30:56", role: "user">, #<User id: 4, name: "David", email: "david@test.abc", created_at: "2018-12-26 14:31:32", updated_at: "2018-12-26 14:31:32", role: "user">, #<User id: 5, name: "Elvis", email: "elvis@test.abc", created_at: "2018-12-26 14:32:04", updated_at: "2018-12-26 23:25:49", role: "user">, #<User id: 7, name: "flavio", email: "flavio@test.abc", created_at: "2018-12-26 14:50:20", updated_at: "2018-12-26 23:25:58", role: "user">]>
~~~~~~~~

prendiamo una lista di tutti i :moderator

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
> User.moderator
 => #<ActiveRecord::Relation []> 
~~~~~~~~

usciamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
>exit
~~~~~~~~




## Attiviamo la white list

Invece di cambiare i ruoli da console adesso li cambiamo sulla nostra view.
Abbiamo un piccolo problema. Devise non è come lo scaffold. Non ci crea già le azioni sul controller e le views.

Per poter passare i parametri attraverso le views, o meglio il sumbit del form, dobbiamo inserirli nella white list del controller. Una procedura detta "Strong_params" o "mass-assignment". Ma questo non è così facile su Devise perché di default ci nasconde tutto.

Abbiamo già visualizzato i controllers e le views di devise-users nei capitoli precedenti.
Possiamo passare i parametri in due modi:

1. Usando il controller application (metodo raccomandato dalla Plataformatec creatrice di Devise)
2. Usando il controller user/registration_controller ma in questo caso dobbiamo dichiararlo nella routes




### 1. Il metodo raccomandato da plataformatec. Il metodo Lazy way.

Mettiamo nella whitelist la colonna :role

{title=".../app/controllers/application_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ApplicationController < ActionController::Base
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.permit(:sign_in, keys: [:role])
    devise_parameter_sanitizer.permit(:sign_up, keys: [:role])
    devise_parameter_sanitizer.permit(:account_update, keys: [:role])
  end
end
~~~~~~~~

[cod. c](beginning-authorization-03c-application_controller.rb)

Their names and default permitted parameters are:

* sign_in (Devise::SessionsController#create) - Permits only the authentication keys (like email)
* sign_up (Devise::RegistrationsController#create) - Permits authentication keys plus password and password_confirmation
* account_update (Devise::RegistrationsController#update) - Permits authentication keys plus password, password_confirmation and current_password




### 2. Questa alternativa è una bozza da sistemare meglio
    
{title=".../app/controllers/users/registrations_controller.rb", lang=ruby, line-numbers=on, starting-line-number=11}
~~~~~~~~
class RegistrationsController < Devise::RegistrationsController

  ...

  private

  def sign_up_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation)
  end

  def account_update_params
    params.require(:user).permit(:role, :email, :password, :password_confirmation, :current_password)
  end
end
~~~~~~~~

Aggiungiamo instradamento users/registrations per devise

{title=".../app/config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=8}
~~~~~~~~
  devise_for :users, controllers: {sessions: 'users/sessions', registration: 'users/registration'}, path: '', path_names: {sign_in: 'login'}
~~~~~~~~




## Aggiorniamo la view

Aggiungiamo un selettore per permettere di cambiare ruolo

{title=".../app/views/users/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
~~~~~~~~
    <%= form.select(:role, User.roles.keys.map {|role| [role.titleize, role]}) %>
~~~~~~~~

[tutto il codice](#beginning-authentication-authorization-06b-views-users-_form.html.erb)




## Spiegazione didattica su **.select**

Per il selettore avremmo potuto usare form.collection_select al posto di form.select ?

~~~~~~~~
    <%= form.collection_select(:city_id, City.all, :id, :name) %>
~~~~~~~~

Nel nostro caso no perché form.collection_select lavora su una tabella; invece noi stiamo usando |enum| sulla colonna :role della tabella users.
  

Altri esempi di form.select per chiarire meglio come lavora:

~~~~~~~~
<%= form_for @post do |form| %>
  <%= form.select :person_id, Person.all.map { |p| [ p.name, p.id ] }, include_blank: true %>
  <%= form.submit %>
<% end %>
~~~~~~~~

~~~~~~~~
@users = User.all
<% form_for @user, :html => { :method => :post } do |form| %>
  <%= form.select :user_id, @users %>
~~~~~~~~

~~~~~~~~
<% form_for @user, :html => { :method => :post } do |form| %>
  <%= form.select :user_id, @users.collect { |user| [user.name, user.id] } %>
~~~~~~~~

~~~~~~~~
<%= form.select :estados, ['SP', 'PA', 'RJ'] %>
~~~~~~~~

~~~~~~~~
<%= form.select :estados, [['São Paulo', 'SP'], ['Pará', 'PA'], ['Rio de Janeiro', 'RJ']] %>
~~~~~~~~




## Spiegazione didattica su differenza fra each, map, collect

http://queirozf.com/entries/ruby-map-each-collect-inject-reject-select-quick-reference
https://stackoverflow.com/questions/9429034/what-is-the-difference-between-map-each-and-collect




### each
Executes an action using as parameter each element of the array. Returns the unmodified array.

[1,2,3,4,5,6,7,8,9,10].each{|e| print e.to_s+"!" }
# prints "1!2!3!4!5!6!7!8!9!10!"
# returns [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 

each performs the enclosed block for each element in the (Enumerable) receiver:

[1,2,3,4].each {|n| puts n*2}
# Outputs:
# 2
# 4
# 6
# 8



### map
Performs an action on each array element. Returns the modified array. The original array is NOT modified.

[1,2,3,4,5,6,7,8,9,10].map{|e| e*3 }
# returns [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]

map produce a new Array containing the results of the block applied to each element of the receiver:

[1,2,3,4].map {|n| n*2}
# => [2,4,6,8]




#### map! 
Performs an action on each array element. Returns the modified array. The original array IS modified.

a = [1,2,3,4]

a.map {|n| n*2} # => [2,4,6,8]
puts a.inspect  # prints: "[1,2,3,4]"

a.map! {|n| n+1}
puts a.inspect  # prints: "[2,3,4,5]"




### collect 
Alias for map
map and collect are the same. Technically map is an alias for collect, but map is used a lot more frequently.
map is the community-choosen version ( https://github.com/bbatsov/ruby-style-guide#map-fine-select-reduce-size )




## Implementiamo le autorizzazioni

nel prossimo capitolo finalmente attiviamo la sicurezza implementando le autorizzazioni alle varie azioni.
