# Git

Version Control System. Un gestore che controlla le versioni del software in fase di sviluppo.




## Implementiamo Git 

implementare git richiede i pochi comandi presentati su questo paragrafo. Se volete implementarlo con più calma usando anche altri comandi di controllo passate al paragrafo successivo. 

{title="Sommario del capitolo Git", lang=bash, line-numbers=off}
~~~~~~~~
$ cd rebisworldbr
$ git init

$ git add -A
$ git commit -m "new rails app"

$ git tag v0.1.0
~~~~~~~~

I> Ricordiamoci di entrare nella directory del nostro nuovo applicativo "rebisworldbr" altrimenti si inizializza git per tutto il workspace e questo è un problema per quando si fa il push su heroku.




## Inizializziamo

Entriamo nella directory del nostro nuovo applicativo

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ cd rebisworld
~~~~~~~~

Vediamo che non ci sono le cartelle nascoste di git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ ls -a
~~~~~~~~

inizializziamo git.  

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git init
~~~~~~~~

Questo genera anche la cartella nascosta git ed i vari files tra cui gitignore per vedere possiamo visualizzare i files nascosti dalla ruota dentata al lato del nome del workspace scegliendo dal menu a discesa la voce "show hidden files"
Oppure da terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ ls -a
~~~~~~~~




## Verifichiamo configurazione globale 

Verifichiamo la configurazione globale di git che è utilizzata per i repository esterni quali Github, Heroku, Gitbuchet, ...
Per verificare le impostazioni di git eseguiamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git config -l
~~~~~~~~

Se serve modificarle

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git config --global user.name "Your Name"
$ git config --global user.email "your@email.com"
$ git config --global push.default matching
~~~~~~~~




## Escludiamo files da git

Escludiamo da git quei files che non fanno parte del codice. Ad esempio i files temporanei o quelli di log o file di configurazione di 
pacchetti accessori [Gitignore - ignoring files](https://help.github.com/articles/ignoring-files).
Altri files che è importante escludere sono quelli riguardanti password/secrets. Ma questi ultimi li trattiamo nel futuro capitolo che si intitola Figaro.

Cloud9 nel workspace rails inserisce un gitignore di default che al momento lasciamo così ma che modificheremo in seguito

{title=".../.gitignore", lang=text, line-numbers=on, starting-line-number=1}
~~~~~~~~
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'

# Ignore bundler config.
/.bundle

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore uploaded files in development
/storage/*

/node_modules
/yarn-error.log

/public/assets
.byebug_history

# Ignore master key for decrypting credentials and more.
/config/master.key
~~~~~~~~




## Versione iniziale v0.1.0

Effettuiamo il primo commit ed eseguiamo anche il tag v.0.1.0 in accordo con la convenzione del [semantic versioning](http://semver.org)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "new rails app"

$ git tag v0.1.0
~~~~~~~~

il tag ci permette di distingure delle "pietre miliari" durante lo sviluppo. Tappe che vengono identificate da un cambio del numero della versione.
Il numero di versione segue le convenzioni del semantic versioning (semver.org)




## Branch

Il nome del ramo principale in Git è master. Quando si inzia a fare dei commit, li stai dando al ramo master che punterà
all'ultimo commit che hai eseguito. Creando un nuovo ramo o branch il puntatore si sposterà su quest'ultimo lasciando
inalterato il ramo master.

Nei prossimi capitoli utlizzeremo SEMPRE il Branch per fare le modifiche e poi lo eliminiamo dopo aver passato le modifiche sul master (operazione di merge).
Ogni volta che facciamo una modifica "anche piccola" apriamo un branch.
Il branch ci permette di tornare indietro se abbiamo fatto casini.
Fare un branche anche per piccole modifiche ci limita problemi di "merge" da risolvere.

### Creiamo un nuovo ramo e ci spostiamo su esso.

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b nomebranch
~~~~~~~~

I> Non è indispensabile creare e spostarsi sul nuovo branch prima di fare le modifiche perché le modifiche vengono passate su git solo quando si fa il ** git add **. E' comunque buona prassi iniziare creando il branch prima di modificare il codice.




### Lavoriamo sul codice e aggiorniamo il ramo

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "modifiche fatte"


$ git add -A
$ git commit -m "modifiche fatte2"


$ git add -A
$ git commit -m "modifiche fatte3"

...
~~~~~~~~




### Chiudiamo il ramo

se abbiamo finito le modifiche e va tutto bene:

{title="Riassunto del capitolo", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge nomebranch
$ git branch -d nomebranch
~~~~~~~~


se abbiamo fatto casino e vogliamo tornare indietro abortando il branch:

{title="Riassunto del capitolo", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git branch -D nomebranch
~~~~~~~~




## Considerazioni finali del capitolo

Il version control system Git è utile per:

1. tener traccia dell'andamento dei lavori. 
2. avere tranquillità di poter tornare indietro con i branches
3. pubblicare la nostra applicazione su Heroku
