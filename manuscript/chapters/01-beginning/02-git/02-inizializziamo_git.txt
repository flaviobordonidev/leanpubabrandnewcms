# Git

Version Control System. Un gestore che controlla le versioni del software in fase di sviluppo.




## Inizializziamo

Entriamo nella directory del nostro nuovo applicativo

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ cd rebisworld
~~~~~~~~

Vediamo che non c'è le cartelle nascoste **.git**

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ ls -a
~~~~~~~~

inizializziamo git.  

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git init
~~~~~~~~

I> Ricordiamoci di entrare nella directory del nostro nuovo applicativo "rebisworldbr" altrimenti si inizializza git per tutto il workspace e questo è un problema per quando si fa il push su heroku.

Questo genera anche la cartella nascosta git ed i vari files tra cui gitignore per vedere possiamo visualizzare i files nascosti dalla ruota dentata al lato del nome del workspace scegliendo dal menu a discesa la voce "show hidden files"

![Fig. a](beginning/git/01a-aws_cloud9-show_hidden_files.png)


Oppure da terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ ls -a
~~~~~~~~




## La configurazione globale 

Verifichiamo la configurazione globale di git che è utilizzata per i repository esterni quali Github, Heroku, Gitbuchet, ...
Per verificare le impostazioni di git eseguiamo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git config -l
~~~~~~~~

First-time system setup
Before using Git, you should perform a couple of one-time setup steps. These are system setups, meaning you only have to do them once per computer:


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git config --global user.name "Your Name"
$ git config --global user.email "your@email.com"
~~~~~~~~

Note that the name and email address you use in your Git configuration will be available in any repositories you make public.
Questo ci sarà utile più avanti quando attiveremo GitHub perché useremo la stessa email per avere accesso.

Verifichiamo le aggiunte fatte

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git config -l
~~~~~~~~




## Escludiamo files da git

Escludiamo da git quei files che non fanno parte del codice. Ad esempio i files temporanei o quelli di log o file di configurazione di 
pacchetti accessori [Gitignore - ignoring files](https://help.github.com/articles/ignoring-files).
Altri files che è importante escludere sono quelli riguardanti password/secrets. Ma questi ultimi li trattiamo nel futuro capitolo che si intitola Figaro.

Cloud9 nel workspace rails inserisce un gitignore di default che al momento lasciamo così ma che modificheremo in seguito

![Fig. a](beginning/git/01a-aws_cloud9-show_hidden_files.png)


{title=".../.gitignore", lang=text, line-numbers=on, starting-line-number=1}
~~~~~~~~
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'

# Ignore bundler config.
/.bundle

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore uploaded files in development
/storage/*

/node_modules
/yarn-error.log

/public/assets
.byebug_history

# Ignore master key for decrypting credentials and more.
/config/master.key
~~~~~~~~

![tutto il codice](beginning/git/01b-.gitignore)




## Versione iniziale v0.1.0

Effettuiamo il primo commit ed eseguiamo anche il tag v.0.1.0 in accordo con la convenzione del [semantic versioning](http://semver.org)

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "new rails app"

$ git tag v0.1.0
~~~~~~~~

il tag ci permette di distingure delle "pietre miliari" durante lo sviluppo. Tappe che vengono identificate da un cambio del numero della versione.
Il numero di versione segue le convenzioni del semantic versioning (semver.org)




## Branch

Il nome del ramo principale in Git è master. Quando si inzia a fare dei commit, li stai dando al ramo master che punterà
all'ultimo commit che hai eseguito. Creando un nuovo ramo o branch il puntatore si sposterà su quest'ultimo lasciando
inalterato il ramo master.

Nei prossimi capitoli utlizzeremo SEMPRE il Branch per fare le modifiche e poi lo eliminiamo dopo aver passato le modifiche sul master (operazione di merge).
Ogni volta che facciamo una modifica "anche piccola" apriamo un branch.
Il branch ci permette di tornare indietro se abbiamo fatto casini.
Fare un branche anche per piccole modifiche ci limita problemi di "merge" da risolvere.

### Creiamo un nuovo ramo e ci spostiamo su esso.

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b nomebranch
~~~~~~~~

I> Non è indispensabile creare e spostarsi sul nuovo branch prima di fare le modifiche perché le modifiche vengono passate su git solo quando si fa il ** git add **. E' comunque buona prassi iniziare creando il branch prima di modificare il codice.




### Lavoriamo sul codice e aggiorniamo il ramo

{title="terminale", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "modifiche fatte"


$ git add -A
$ git commit -m "modifiche fatte2"


$ git add -A
$ git commit -m "modifiche fatte3"

...
~~~~~~~~




### Chiudiamo il ramo

se abbiamo finito le modifiche e va tutto bene:

{title="Riassunto del capitolo", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge nomebranch
$ git branch -d nomebranch
~~~~~~~~


se abbiamo fatto casino e vogliamo tornare indietro abortando il branch:

{title="Riassunto del capitolo", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git branch -D nomebranch
~~~~~~~~




## Considerazioni finali del capitolo

Il version control system Git è utile per:

1. tener traccia dell'andamento dei lavori. 
2. avere tranquillità di poter tornare indietro con i branches
3. pubblicare la nostra applicazione su Heroku
