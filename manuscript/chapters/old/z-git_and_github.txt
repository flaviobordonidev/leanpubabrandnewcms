# Git and GitHub




## web references

  * https://git-scm.com/book/en/v2/Git-Basics-Tagging
  * http://stackoverflow.com/questions/7813194/how-do-i-edit-an-existing-tag-message-in-git
  * https://allenan.com/git-branch-naming-conventions/
  * http://www.pivotaltracker.com/help/gettingstarted
  * http://nvie.com/posts/a-successful-git-branching-model/




## Git - il repository locale

Git è un version control system bla bla bla




## GitHub - il repository esterno

Aggiungiamo un repository esterno per git. Usiamo github. Creiamo un nuovo repository su github
Facciamo login come Integram-system e creiamo il repository canvas
https://github.com/Integram-System/canvas

A> $ git remote add origin https://github.com/Integram-System/canvas.git
A>
A> $ git push -u origin master

Usando "push -u" fissiamo il remote repository "origin" ed il branch "master" e non abbiamo bisogno di doverlo ripetere tutte le volte. Quindi da adesso in poi sara sufficiente:

A> $ git push




## git tag

Per passare anche il tag usiamo

A> $ git push --tag

I> Correggiamo la descrizione sul tag mettendo anche la versione v.0.1.0 in accordo con il semantic versioning (http://semver.org/) che identifica v.Major.Minor.Patch

vediamo la lista dei tags:

$ git tag

flavio@flubuntu:~/Sites/canvas$ git tag
beginning

eliminiamo il tag sul git locale.

$ git tag -d beginning

eliminiamo da web il tag su github. (Click su canvas -> releases -> tag "beginning" -> delete)

creiamo un nuovo tag

$ git tag v0.0.1

aggiorniamo github

$ git push --tag




## La routine giornaliera

Ogni volta che voglio contribuire ad un progetto che ho già clonato: entro nella directory del progetto; prendo le ultime modifiche da github con un "pull"; mi apro un branch diverso dal master e ci entro; lavoro un poco; faccio il mio "snapshot" sul mio git locale; chiudo lo "snapshot" con un commento scritto all'imperativo PRESENTE; verifico che le modifiche funzionano anche su heroku (opzionale); invio le mie nuove modifiche su github con un "push".

A> $ git pull origin master
A>
A> $ git checkout -b my_branch_name
A>
A> $ git push origin my_branch_name
A>
A> ... faccio questo e quello... (lavoro un poco)
A>
A> $ git add -A
A>
A> $ git commit -m "fai questo e quello"
A>
A> $ git push heroku my_branch_name:master
A>
A> $ git push origin my_branch_name

Se non ho finito di completare la "story" del mio nuovo branch continuo: prendo le ultime modifiche da github con un "pull" dal nuovo ramo (branch_name); lavoro un poco; faccio il mio "snapshot" sul mio git locale; chiudo lo "snapshot" con un commento scritto all'imperativo PRESENTE; verifico che le modifiche funzionano anche su heroku (opzionale); invio le mie nuove modifiche su github con un "push".

A> $ git pull origin my_branch_name
A>
A> ... faccio questo e quello... (lavoro un poco)
A>
A> $ git add -A
A>
A> $ git commit -m "fai questo e quello"
A>
A> $ git push heroku my_branch_name:master
A>
A> $ git push origin my_branch_name

Una volta finito con la "story" esco dal branch e richiedo su github un merge (Faccio una "pull request"). Una volta accordata procedo a fare il merge (oppure lo fa chi ne ha i diritti):

A> $ git checkout master
A>
A> $ git merge my_branch_name
A>
A> $ git push origin master

Poi elimino il branch sia in locale che in remoto (su github)

A> $ git branch -d my_branch_name
A>
A> $ git push origin :my_branch_name

Fine della mia routine.




## Configurazione iniziale

A> $ git config --global user.name "Your Name"
A> 
A> $ git config --global user.email your.email@example.com
A> 
A> $ git config --global push.default matching
A> 
A> $ git config --global alias.co checkout


A> $ git init
A> 
A> $ ll
A> 
A> $ git status
A> 
A> $ git add -A
A> 
A> $ git commit -m "begin of romasportface"
A> 
A> $ git status
A> 
A> $ git tag v0.1.0

Per vedere l'elenco dei tag (in questo caso solo uno) e per vedere l'elenco dei commit

A> $ git tag
A> 
A> $ git log




## Creo un branch a partire dal master.

A> $ git checkout master
A>
A> $ git checkout -b my_new_branch

Visualizzo la lista dei branches 

A> git branches

Aggiorno github

A> $ git push -u origin my_new_branch

l'opzione "-u" mi permette di poter chiamare in futuro solo "$ git push" ma preferisco non usarlo per evitare errori. Preferisco indicare sempre il repository remoto ( "origin" in questo caso punta a Github) ed il branch che voglio inviare (my_new_branch in questo caso)

A> $ git push origin my_new_branch



## Recuperare da un errore

Se si fanno errori si può ripristinare tutto all'ultimo commit con

A> $ git checkout -f

[...]
Tratto da https://www.railstutorial.org/book/beginning

If you’ve never used version control before, it may not be entirely clear at this point what good it does you, so let me give just one example. Suppose you’ve made some accidental changes, such as (D’oh!) deleting the critical app/controllers/ directory.

A> $ ls app/controllers/
A>
A>    application_controller.rb  concerns/
A>
A> $ rm -rf app/controllers/
A>
A> $ ls app/controllers/
A>    ls: app/controllers/: No such file or directory

Here we’re using the Unix ls command to list the contents of the app/controllers/ directory and the rm command to remove it (Table 1.1). The -rf flag means “recursive force”, which recursively removes all files, directories, subdirectories, and so on, without asking for explicit confirmation of each deletion.

Let’s check the status to see what changed:

A> $ git status
A> 
A> On branch master
A> 
A> Changed but not updated:
A> 
A>   (use "git add/rm <file>..." to update what will be committed)
A> 
A>   (use "git checkout -- <file>..." to discard changes in working directory)
A> 
A>       deleted:    app/controllers/application_controller.rb

no changes added to commit (use "git add" and/or "git commit -a")
We see here that a file has been deleted, but the changes are only on the “working tree”; they haven’t been committed yet. This means we can still undo the changes using the checkout command with the -f flag to force overwriting the current changes:

A> $ git checkout -f
A> 
A> $ git status
A> 
A> # On branch master
A> 
A> nothing to commit (working directory clean)
A> 
A> $ ls app/controllers/
A> 
A> application_controller.rb  concerns/
A> 
A> The missing files and directories are back. That’s a relief!

[...]




I> Web resources
I> Github Tutorial For Beginners - Github Basics for Mac or Windows & Source Control Basics
I> * https://www.youtube.com/watch?v=0fKg7e37bQE 

I> GITHUB PULL REQUEST, Branching, Merging & Team Workflow
I> *https://www.youtube.com/watch?v=oFYyTZwMyAg&list=PLoYCgNOIyGAB_8_iq1cL8MVeun7cB6eNc&index=10&feature=iv&src_vid=0fKg7e37bQE&annotation_id=annotation_3593094967

I> Are git forks actually git clones?
I> http://stackoverflow.com/questions/6286571/are-git-forks-actually-git-clones

I> git - the simple guide
I> http://rogerdudler.github.io/git-guide/



## Revert to a previous commit

Voglio tornare al commit "add back all javascripts files" mi basta vedere il suo id con la log e poi usare "git revert..."" e "git commit" vuoto per forzare.

A> $ git log

~~~~~~~~
.
.
.

commit fc7244b7d7bca02754b952a2e3736e891121b8eb
Author: Flavio Bordoni <flavio.bordoni.dev@gmail.com>
Date:   Thu Jan 21 22:26:03 2016 +0100

    add back all javascripts files

commit 39bf910363c4ad0b2eddf6f1dc20a83658f10646
Author: Flavio Bordoni <flavio.bordoni.dev@gmail.com>
Date:   Thu Jan 21 22:22:02 2016 +0100

    add back bootstrap.css

commit 57ed0ce119902eccbb85113ae9d44ba211e3f985
Author: Flavio Bordoni <flavio.bordoni.dev@gmail.com>
Date:   Thu Jan 21 22:17:24 2016 +0100

    rename style.scss because heroku fails

commit f23617aedb9c5c180d494e9093465e437fa0b44b
Author: Flavio Bordoni <flavio.bordoni.dev@gmail.com>
Date:   Thu Jan 21 22:13:37 2016 +0100
~~~~~~~~

A> $ git revert --no-commit fc7244b7d7bca02754b952a2e3736e891121b8eb..HEAD
A>
A> $ git commit -m "revert to fc7244b..."


///


## Taglia i rami

(http://www.gitguys.com/topics/adding-and-removing-remote-branches/)

Tagliare i rami in git è anche detto potare (to prune). Basta tornare sul ramo principale con (git checkout master) e chiamare il branch con il parametro "-d"

A> git checkout master
A>
A> git branch -d my_branch_name

Le potature fatte localmente non sono riportate anche in remoto.
Se si vuole potare anche sul repository remoto, nel nostro caso Github, si può fare direttamente dall'interfaccia web oppure con il comando:

A> git push origin :my_branch_name

I due punti ":" messi prima del nome del ramo indicano che si vuole tagliare il ramo. Una versione più descrittiva dello stesso identico comando è:

A> git push origin --delete my_branch_name




## Github Workflow


https://github.com/Kunena/Kunena-Forum/wiki/Create-a-new-branch-with-git-and-manage-branches


xxx

https://git-scm.com/book/en/v2/GitHub-Contributing-to-a-Project

The GitHub Flow
GitHub is designed around a particular collaboration workflow, centered on Pull Requests. This flow works whether you’re collaborating with a tightly-knit team in a single shared repository, or a globally-distributed company or network of strangers contributing to a project through dozens of forks. It is centered on the Topic Branches workflow covered in Git Branching.

Here’s how it generally works:

Create a topic branch from master.

Make some commits to improve the project.

Push this branch to your GitHub project.

Open a Pull Request on GitHub.

Discuss, and optionally continue committing.

The project owner merges or closes the Pull Request.

This is basically the Integration Manager workflow covered in Integration-Manager Workflow, but instead of using email to communicate and review changes, teams use GitHub’s web based tools.

Let’s walk through an example of proposing a change to an open source project hosted on GitHub using this flow.

xxxx


Github sul mio git locale si chiama "origin"
Github può avere vari rami "banches", ma deve avere per lo meno un ramo: il ramo di default.
Il ramo di default si chiama "master" 

La giornata lavorativa di Bob e Fla seguiva questi semplici rituali:

Bob è quello che ha aperto il programma su github ed ha invitato Fla. Quindi è Bob che può integrare le modifiche (merge).


1. Fla entra nella cartella dell'applicazione e scaricare gli ultimi aggiornamenti da github

A> $ cd ~/Sites/romasportface
A> $ git pull origin master


2. E' la v0.1.0. Apre una nuova "story" per la "feature" "climb a mountain" ed aggiorna github

A> $ git checkout -b ft-climb_a_mountain-001
A>
A> $ git push origin ft-climb_a_mountain-001


3. lavora sulla "story" ed aggiorna github

A> $ git add -A
A>
A> $ git commit -m "one more drop of sweat"
A>
A> $ git push origin ft-climb_a_mountain-001


A> $ git add -A
A>
A> $ git commit -m "we are almost there"
A>
A> $ git push origin ft-climb_a_mountain-001


A> $ git add -A
A>
A> $ git commit -m "this story is done"
A>
A> $ git push origin ft-climb_a_mountain-001


4. Finita la "story" chiede a Bob se può integrarla sul programma.

Su github clicca il pulsante "New pull request". Questo in automatico manda un'email a Bob che vede le modifiche e manda un messaggio su Github di Tutto ok! Integriamola sul programma.


5. Bob aggiorna il branch, fa il merge ed aggiorna github

A> $ git pull origin ft-climb_a_mountain-001
A> 
A> $ git checkout master
A>
A> $ git merge --no-ff ft-climb_a_mountain-001
A>
A> $ git push origin master
A>
A> $ git tag v0.2.0
A>
A> $ git push --tag 





## esempio vario


A> flavio@flubuntu:~/Sites/canvas$ git remote add origin https://github.com/Integram-System/canvas.git
A> flavio@flubuntu:~/Sites/canvas$ git push -u origin master
A> Username for 'https://github.com': info@integram-system.com
A> Password for 'https://info@integram-system.com@github.com': 
A> To https://github.com/Integram-System/canvas.git
A>  * [new branch]      master -> master
A> Branch master set up to track remote branch master from origin.
A> flavio@flubuntu:~/Sites/canvas$ 



---
---
---



# Heroku

$ heroku create

$ heroku git:remote -a tranquil-meadow-6436

$ heroku run rake db:migrate --app stark-plateau-6287

$ heroku open --app stark-plateau-6287




Questo il gemfile dell'applicazione scaricata da Heroku

~~~~~~~~
source 'https://rubygems.org'
ruby '2.2.4'

# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
gem 'rails', '4.2.3'
# Use postgresql as the database for Active Record
gem 'pg'
gem 'rails_12factor', group: :production
# Use SCSS for stylesheets
gem 'sass-rails', '~> 5.0.3'
# Use Uglifier as compressor for JavaScript assets
gem 'uglifier', '>= 1.3.0'
# Use CoffeeScript for .js.coffee assets and views
gem 'coffee-rails', '~> 4.0.0'
# See https://github.com/sstephenson/execjs#readme for more supported runtimes
# gem 'therubyracer',  platforms: :ruby

# Use jquery as the JavaScript library
gem 'jquery-rails'
# Turbolinks makes following links in your web application faster. Read more: https://github.com/rails/turbolinks
gem 'turbolinks'
# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
gem 'jbuilder', '~> 2.0'
# bundle exec rake doc:rails generates the API under doc/api.
gem 'sdoc', '~> 0.4.0',          group: :doc

# Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
gem 'spring',        group: :development

# Use ActiveModel has_secure_password
# gem 'bcrypt', '~> 3.1.7'

gem 'puma'

# Use Capistrano for deployment
# gem 'capistrano-rails', group: :development

# Use debugger
# gem 'debugger', group: [:development, :test]

~~~~~~~~


Deploying Rails Applications with the Puma Web Server
https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server

Railstutorial - 7.5.2 Production webserver
https://www.railstutorial.org/book/sign_up#sec-professional_grade_deployment



## Heroku Deploy from a Branch

https://devcenter.heroku.com/articles/git

Branches pushed to Heroku other than master will be ignored by this command. If you’re working out of another branch locally, you can either merge to master before pushing, or specify that you want to push your local branch to a remote master. To push a branch other than master, use this syntax:

A> $ git push heroku yourbranch:master


## Heroku and the ASSET PIPELINE of RAILS

https://devcenter.heroku.com/articles/rails-asset-pipeline

https://devcenter.heroku.com/articles/rails-4-asset-pipeline


A> $ RAILS_ENV=production bundle exec rake assets:precompile
A>
A> $ git add -A
A>
A> $ git commit -m "vendor compiled assets"



