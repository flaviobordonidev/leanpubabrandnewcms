# Login con Devise - installazione

Aggiungiamo la gemma **devise** alla nostra applicazione per implementare la parte di autenticazione.

Implementiamo la parte di login con la gemma "devise"

devise permette di autenticare l'utente per mezzo di un login con user e password. 
Un utente si logga per avere il SUO ambiente di lavoro personalizzato.

Implementiamo la parte di autenticazione.
La parte di autorizzazione sarà trattata in una sezione differente.
The process of authorization is distinct from that of authentication. Whereas authentication is the process of verifying that "you are who you say you are", authorization is the process of verifying that "you are permitted to do what you are trying to do".


Risorse web:

  * https://github.com/plataformatec/devise
  * https://github.com/plataformatec/devise/wiki/Example-Applications
  * http://railsapps.github.io/tutorial-rails-devise-rspec-cucumber.html
  * http://railsapps.github.io/tutorial-rails-mongoid-devise.html
  * Railscasts pro 209-devise-revised
  * http://railsapps.github.io/tutorial-rails-mongoid-devise.html




## Apriamo il branch "Login Devise Install"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b ldi
~~~~~~~~




## Installiamo la gemma devise

I> verifichiamo [l'ultima versione della gemma](https://rubygems.org/gems/devise)
I>
I> facciamo riferimento al [tutorial github della gemma](https://github.com/plataformatec/devise)

{title="Gemfile", lang=ruby, line-numbers=on, starting-line-number=50}
~~~~~~~~
# Flexible authentication solution for Rails with Warden 
gem 'devise', '~> 4.4', '>= 4.4.3'
~~~~~~~~

[tutto il codice: Gemfile](#brandnewcms-07code-gemfile.rb)

Eseguiamo l'installazione della gemma con bundle 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ bundle install
~~~~~~~~




## Lo script

Eseguiamo lo script di installazione di devise su rails (Anche noto con il nome di "generator").
Il "generator" installerà un inizializzatore che descrive tutte le opzioni di configurazione di Devise. E' importante leggere e seguire le varie azioni proposte.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g devise:install

Running via Spring preloader in process 7804
      create  config/initializers/devise.rb
      create  config/locales/devise.en.yml
===============================================================================

Some setup you must do manually if you haven't yet:

  1. Ensure you have defined default url options in your environments files. Here
     is an example of default_url_options appropriate for a development environment
     in config/environments/development.rb:

       config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }

     In production, :host should be set to the actual host of your application.

  2. Ensure you have defined root_url to *something* in your config/routes.rb.
     For example:

       root to: "home#index"

  3. Ensure you have flash messages in app/views/layouts/application.html.erb.
     For example:

       <p class="notice"><%= notice %></p>
       <p class="alert"><%= alert %></p>

  4. You can copy Devise views (for customization) to your app by running:

       rails g devise:views

===============================================================================
~~~~~~~~

Completiamo i 4 punti riportati sul testo che appare dopo devise:install.




### Punto 1

relativo alla parte di settaggio sia in sviluppo che in produzione.

{title=".../config/environments/development.rb", lang=ruby, line-numbers=on, starting-line-number=34}
~~~~~~~~
  # Devise config
  config.action_mailer.default_url_options = { :host => 'localhost:3000' }
~~~~~~~~

[tutto il codice](#brandnewcms-07code-config-environments-development.rb)

Nel prossimo passaggio dobbiamo mettere l'host di produzione. Nel nostro caso quello di heroku. 
Per trovare il nome host su heroku o ci loggiamo oppure usiamo il comando:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku domains
~~~~~~~~

Adesso che abbiamo il nome dell'host su heroku lo possiamo usare nel file di configurazione.

{title=".../config/environments/production.rb", lang=ruby, line-numbers=on, starting-line-number=65}
~~~~~~~~
  # Devise config
  config.action_mailer.default_url_options = { :host => 'fast-brook-60500.herokuapp.com' }
~~~~~~~~

[tutto il codice](#brandnewcms-07code-config-environments-production.rb)

I> Attenzione!
I>
I> Dobbiamo ricordarci di cambiare questo settaggio quando su Heroku punteremo al dominio definitivo. (https://devcenter.heroku.com/articles/using-the-cli).





### punto 2.

Per la root sul root file lasciamo **root 'homepage#show'**.




### punto 3.

dovremmo mettere su .../app/views/layouts/application.html.erb le chiamate 

~~~~~~~~
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
~~~~~~~~

Ma è già presente il

~~~~~~~~
<%= render 'layouts/flash_messages' %>
~~~~~~~~

quindi lasciamo tutto come sta. (Non è vero l'ho messo su layouts/authors.html.erb -- DA SCRIVERE MEGLIO)




### punto 4.

Copiamo le views di devise sulla app per permettere personalizzazione.
Questa operazione la posticipiamo al momento della creazione della tabella **users**.




## Attiviamo la tabella authors con devise

Implementiamo il MODEL di devise "User" che crea anche la tabella users usando il **rails** **generate** **devise** ***Model***.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g devise Author
~~~~~~~~

Aggiungiamo una colonna di tipo string al migrate

{title=".../db/migrate/xxx_devise_create_authors.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
      t.string :name
~~~~~~~~

[tutto il codice](#brandnewcms-07code-db-migrate-xxx_devise_create_authors.rb)

Prima di effettuare il migrate verifichiamo il MODEL per eventuali ulteriori opzioni di configurazione che si potrebbe desiderare di aggiungere, ad esempio "confirmable" o "lockable". Se si aggiunge un'opzione, assicurarsi di ispezionare il file di migrate (creato dal generator) e decommentare la sezione appropriata. Ad esempio, se si aggiunge l'opzione "confirmable" nel modello, è necessario togliere il commento alla sezione Confirmable nel migrate.

commentiamo :registerable nel model perché non vogliamo che sia possibile per gli utenti registrarsi come autore

{title=".../app/models/author.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
class Author < ApplicationRecord
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :registerable, :timeoutable and :omniauthable
  devise :database_authenticatable,
         :recoverable, :rememberable, :trackable, :validatable
end
~~~~~~~~


Effettuiamo il migration.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




## lavoriamo sulle routes.

Sistemiamo gli instradamenti per la parte di autenticazione gestita tramite Devise.

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=6}
~~~~~~~~
  devise_for :authors
  namespace :authors do
~~~~~~~~

[tutto il codice](#brandnewcms-07code-config-routes.rb)

I> Attenzione!
I>
I> La route **devise_for :authors** deve essere messa prima di **resources :authors**
I>
I> nel nostro caso deve essere messa prima di **namespace :authors do**




### Aggiungiamo un autore da console

Da notare che, a differenza dei normali inserimenti nel database, questa volta abbiamo anche delle parentesi graffe **{}** da inserire.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> u = Author.new({email: 'flavio@example.com', password: 'password', password_confirmation: 'password'})
> u.save
~~~~~~~~

Se avessimo attivato l'opzione **:confirmable** avremmo dovuto **skippare** la **confirmation**

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> u = User.new({email: 'flavio@example.com', password: 'password', password_confirmation: 'password'})
> u.skip_confirmation!
> u.save
~~~~~~~~

Oppure

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> Author.create(name: 'Flavio Bordoni', email: 'flavio@test.abc', password: 'password', password_confirmation: 'password')
~~~~~~~~




### Verifichiamo che funziona sul browser

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
https://elisinfo6-flaviobordonidev.c9users.io/authors/sign_in
~~~~~~~~




## Aggiungiamo l'utente alla tabella posts

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration add_author_id_to_posts author_id:integer
~~~~~~~~

aggiungiamo l'indice

{title=".../db/migrate/xxx_add_author_id_to_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddAuthorIdToPosts < ActiveRecord::Migration[5.1]
  def change
    add_column :posts, :author_id, :integer
    add_index :posts, :author_id
  end
end
~~~~~~~~

e facciamo il migrate 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




## Lo style per devise?

forse questo paragrafo non serve, ma se serve, dentro application_controller:

~~~~~~~~
layout :for_devise

def for_devise
  'authors'
end
~~~~~~~~

o più semplicemente

~~~~~~~~
layout 'authors'
~~~~~~~~

Ci sono altri metodi per selezionare il layout. (vedi donamat con template Angle)




## Collegamento uno-a-molti


{title=".../app/models/author.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  has_many :posts
~~~~~~~~


{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  belongs_to :author
~~~~~~~~




## Attiviamo la protezione da autenticazione per tutto il modulo Authors

Nel controller authors_controller che abbiamo creato ex-novo nello "split"

{title=".../app/controllers/authors_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AuthorsController < ApplicationController
  before_action :authenticate_author!
end
~~~~~~~~

basta una sola chiamata **:authenticate_author!** che usa devise, per coprire tutto il modulo. Questo uno dei vantaggi di aver incapsulato una copia di posts dentro il modulo authors

siccoma abbiamo diviso tutto quest'unica chiamata protegge tutto il namespace ...authors... 

una volta loggati ci rendiamo conto di vedere ancora tutti i posts e non solo i nostri. Correggiamo nel prossimo paragrafo.




## Filtriamo i posts per utente loggato

Nel controller authors/posts_controller sostituisco **Post** con **current_author.posts** nelle azioni index, new, create e nel metodo privato set_post

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=10}
~~~~~~~~
      @posts = current_author.posts.most_recent
~~~~~~~~

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=21}
~~~~~~~~
      @post = current_author.posts.new
~~~~~~~~

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=32}
~~~~~~~~
      @post = current_author.posts.new(post_params)
~~~~~~~~

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=73}
~~~~~~~~
        @post = current_author.posts.friendly.find(params[:id])
~~~~~~~~




## Effettuiamo il LOGOUT

per usire dall'area dell'autore è sufficiente un link con ** destroy_author_session_path, method: :delete **. Aggiungiamo quindi questa nuova voce nella barra di navigazione.

{title=".../app/views/layouts/_navbar.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=23}
~~~~~~~~
      <li class="nav-item">
        <%= link_to 'Logout', destroy_author_session_path, method: :delete, class: "nav-link" %>
      </li>
~~~~~~~~




## Rendiamo visibile la voce "myposts" solo se siamo loggati

{title=".../app/views/layouts/_navbar.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=18}
~~~~~~~~
      <% if author_signed_in? %>
        <li class="nav-item <%= yield(:authors_active) %>">
          <%= link_to 'My posts', authors_posts_path, class: "nav-link" %>
        </li>
      <% end %>
~~~~~~~~




Per questo capitolo è tutto




salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Install Devise and implement it"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku ldi:master
$ heroku run rails db:migrate
~~~~~~~~

Installando devise siamo intervenuti sul database locale e quindi dobbiamo aggiornare anche quello remoto su Heroku



## Popoliamo da terminale il database su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rails c
> Author.create(name: 'FB', email: 'flavio@test.abc', password: 'password', password_confirmation: 'password')
> exit
~~~~~~~~

Author.create(name: 'Anima Affetto', email: 'affetto@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Apatia', email: 'apatia@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Coinvolgimento', email: 'coinvolgimento@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Contribuizione', email: 'contribuizione@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Dedizione', email: 'dedizione@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Distacco', email: 'distacco@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Oculatezza', email: 'oculatezza@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Profondità', email: 'profondita@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Spreco', email: 'spreco@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Superficialità', email: 'superficialita@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Uno come tanti', email: 'unocometanti@rebisworld.com', password: 'password', password_confirmation: 'password')

Author.create(name: 'Anima Vitalità', email: 'vitalita@rebisworld.com', password: 'password', password_confirmation: 'password')




## ERRORE E TROUBLESHOOTING

Anche se in locale funzionava tutto su heroku avevo un errore quando premevo link per creare nuovo articolo.
guardando le log di heroku ho visto che il problema è sul controller per l'azione new. (Alquanto ovvio ^_^)
L'indizio importante è stato **unknown attribute 'author_id' for Post**

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku logs
  Completed 500 Internal Server Error in 12ms (ActiveRecord: 3.1ms)
  ActiveModel::UnknownAttributeError (unknown attribute 'author_id' for Post.):
  app/controllers/authors/posts_controller.rb:20:in `new'
~~~~~~~~

Ho fatto un po' di prove da terminale e sembrava tutto ok, quando si è accesa la lampadina! Ci siamo scordati di aggiungere :author_id alla lista bianca per il massive assignment. Aggiunta la voce, problema risolto! :)

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=61}
~~~~~~~~
      # Never trust parameters from the scary internet, only allow the white list through.
      def post_params
        params.require(:post).permit(:title, :body, :description, :author_id)
      end
~~~~~~~~




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Fix bug on new post"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku ldi:master
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge ldi
$ git branch -d ldi
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
