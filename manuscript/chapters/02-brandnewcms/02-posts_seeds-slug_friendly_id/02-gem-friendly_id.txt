# Friendly_id gem

FriendlyId is the “Swiss Army bulldozer” of slugging and permalink plugins for ActiveRecord. It allows you to create pretty URL’s and work with human-friendly strings as if they were numeric ids for ActiveRecord models.




## Apriamo il branch "friendly_id"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b fi
~~~~~~~~




## installiamo la gemma friendly_id

I> verifichiamo [l'ultima versione della gemma](https://rubygems.org/gems/friendly_id)
I>
I> facciamo riferimento al [tutorial github della gemma](https://github.com/norman/friendly_id)

{title=".../Gemfile", lang=ruby, line-numbers=on, starting-line-number=62}
~~~~~~~~
# slugging and permalink for Active Record. For creating human-friendly strings URLs and use as if they were numeric ids.
gem 'friendly_id', '~> 5.2', '>= 5.2.4'
~~~~~~~~

[tutto il codice](#brandnewcms-slug-friendly_id-gemfile.rb)

Eseguiamo l'installazione della gemma con bundle

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ bundle install
~~~~~~~~

e lanciamo lo script di installazione

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails generate friendly_id
~~~~~~~~




### Debug

Prima di fare bundle install verifichiamo il migrate creato.
Su versione precedente di friendly_id il migrate era:

{title=".../db/migrate/xxx_create_friendly_id_slugs.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreateFriendlyIdSlugs < ActiveRecord::Migration
~~~~~~~~

Questo dava problemi su rails 5.1 che ha introdotto di esporre le versione rails nel migration.
Nel sito github di FriendlyId dicevano di aggiungerlo quindi diventava:

{title=".../db/migrate/xxx_create_friendly_id_slugs.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreateFriendlyIdSlugs < ActiveRecord::Migration[5.1]
~~~~~~~~

In questa versione di friendly_id in concomitanza con rails 5.2 non viene più chiesto di fare la correzione ed il migrate appare così:


{title=".../db/migrate/xxx_create_friendly_id_slugs.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
migration_class =
  if ActiveRecord::VERSION::MAJOR >= 5
    ActiveRecord::Migration[4.2]
  else
    ActiveRecord::Migration
  end

class CreateFriendlyIdSlugs < migration_class
~~~~~~~~

La cosa curiosa è che per una versione rails superiore a 5 viene messo [4.2]
Mi sarei aspettato di vedere [5.2]
Comunque può darsi che vada bene e quindi lascio [4.2] così come hanno messo loro.




### Migrate

eseguiamo il migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

[tutto il codice](#brandnewcms-slug-friendly_id-db-migrate-xxx_create_friendly_id_slugs.rb)




## Aggiungiamo **slug:string:uniq** alla tabella posts

Per usare la gemma friendly_id dobbiamo aggiungere una colonna alla nostra tabella.
Potevamo aggiungerla subito al comando dello scaffold **$ rails g scaffold Post title:string ... slug:string:uniq** ma aggiungerla dopo è didatticamente più interessante.

Il campo slug è usato da friendly_id ed è una stringa univoca usata per ritrovare il post.id dall'URL human-readable. Se per qualche motivo non avessimo inserito **slug:string:uniq** durante lo scaffold ed avessimo già eseguito il rails db migrate, come in effetti abbiamo fatto ^_^, questo paragrafo fa per noi. Creiamo un nuovo migration in cui aggiungiamo il campo slug:string e l'indice uniq.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration AddSlugUniqToPosts slug:string:uniq
~~~~~~~~

questo crea il migrate:

{title=".../db/migrate/xxx_add_slug_uniq_to_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddSlugUniqToPosts < ActiveRecord::Migration[5.2]
  def change
    add_column :posts, :slug, :string
    add_index :posts, :slug, unique: true
  end
end
~~~~~~~~

eseguiamo il migrate 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




## Implementiamo il model per friendly_id

Come richersto da friendly_id inseriamo due line di codice nel nostro model per dire che l'URL human-readable è basato sul campo "title". 

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=14}
~~~~~~~~
  # == Extensions ===========================================================

  ## friendly_id
  extend FriendlyId
  friendly_id :title, use: :slugged
~~~~~~~~

Inoltre implementiamo/definiamo un metodo per aggiornare lo slug in automatico ogni volta che cambiamo il titolo

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  def should_generate_new_friendly_id?
    title_changed?
  end
~~~~~~~~

[tutto il codice](#brandnewcms-posts_seeds-slug_friendly_id-models-post.rb)

il codice **should_generate_new_friendly_id?** è della gemma friendly_id. 
il codice **title_changed?** è di Rails.




## Implementiamo friendly_id nel controller degli articoli

nel set_post ricerchiamo tramite **:id** ma in modo "friendly" ^_^

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=66}
~~~~~~~~
    def set_post
      @post = Post.friendly.find(params[:id])
    end
~~~~~~~~




## Verifichiamo 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails s -b $IP -p $PORT
~~~~~~~~

Funziona! creo nuovo post (senza riempire il campo slug) e su submit ottengo il nuovo post con URL human-readable ed il campo slug automaticamente riempito. Se faccio edit, cambio il titolo e rifaccio submit, ottengo nuovo URL ed automaticamente nuovo slug.




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Implement friendly_id gem"
~~~~~~~~




## Se avessimo inserito lo "slug" in fase di scaffold...

Se avessimo inserito lo "slug" in fase di scaffold adesso avremmo dovuto pulire un po' il codice: 

nel form non ci sarebbe servito il campo slug perché viene gestito automaticamente. Avremmo dovuto eliminare le linee di codice corrispondenti.

{title=".../app/views/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=29}
~~~~~~~~
  <div class="field">
    <%= form.label :slug %>
    <%= form.text_field :slug, id: :post_slug %>
  </div>
~~~~~~~~

nel posts_controller non ci serve autorizzare il passaggio del parametro slug attraverso mass-assignment quindi lo avremmo dovuto togliere.

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=66}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def post_params
      params.require(:post).permit(:title, :body, :description)
    end
~~~~~~~~

Avremmo salvato su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Clean up a little"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku fi:master
$ heroku run rails db:migrate
~~~~~~~~




## Popoliamo manualmente

Editiamo i quattro articoli (posts) e cambiamo leggermente il titolo. Una volta salvato possiamo vedere friendly_id in azione con lo slug. Ossia nell'url non ci sarà più il numero ad indicare l'articolo ma al suo posto apparirà il titolo dell'articolo, opportunamente formattato per l'url.




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge fi
$ git branch -d fi
~~~~~~~~


## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~

