# acts-as-taggable-on gem

In this episode we set up  tagging for blog posts using the very cool Rails gem “acts-as-taggable-on”. We also dive into some refactoring thoughts.

https://www.youtube.com/watch?v=0j6kySJ4EKs
 



## Apriamo il branch "Taggable Posts"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b tp
~~~~~~~~




## installiamo la gemma acts-as-taggable-on

I> verifichiamo [l'ultima versione della gemma](https://rubygems.org/gems/acts-as-taggable-on)
I>
I> facciamo riferimento al [tutorial github della gemma](https://github.com/mbleigh/acts-as-taggable-on)

{title=".../Gemfile", lang=ruby, line-numbers=on, starting-line-number=66}
~~~~~~~~
# tag a single model on several contexts, such as skills, interests, and awards.
gem 'acts-as-taggable-on', '~> 5.0'
~~~~~~~~

[tutto il codice: Gemfile](#brandnewcms-acts-as-taggable-01code-gemfile.rb)

Eseguiamo l'installazione della gemma con bundle

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ bundle install
~~~~~~~~

e lanciamo lo script di installazione/upgrade

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rake acts_as_taggable_on_engine:install:migrations
~~~~~~~~

Mi crea cinque migrations con della logica per le varie versioni di Rails. Non mi piace molto anche perché sembra limitato a [4.2] e non [5.1] ma per il momento ci adeguiamo e lasciamo così.

[tutto il codice: xxx_acts_as_taggable_on_migration.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_acts_as_taggable_on_migration.acts_as_taggable_on_engine.rb)
[tutto il codice: xxx_add_missing_unique_indices.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_add_missing_unique_indices.acts_as_taggable_on_engine.rb)
[tutto il codice: xxx_add_taggings_counter_cache_to_tags.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_add_taggings_counter_cache_to_tags.acts_as_taggable_on_engine.rb)
[tutto il codice: xxx_add_missing_taggable_index.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_add_missing_taggable_index.acts_as_taggable_on_engine.rb)
[tutto il codice: xxx_change_collation_for_tag_names.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_change_collation_for_tag_names.acts_as_taggable_on_engine.rb)
[tutto il codice: xxx_add_missing_indexes_on_taggings.acts_as_taggable_on_engine](#brandnewcms-acts-as-taggable-01code-db-migrate-xxx_add_missing_indexes_on_taggings.acts_as_taggable_on_engine.rb)

eseguiamo il migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~





## Verifichiamo le routes

non dobbiamo cambiare niente, verifichiamo solo come sono stati inseriti gli instradamenti.

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
...
~~~~~~~~




## Aggiorniamo il model Post

Continuando nel tutorial su github abbiamo la parte di setup. Inseriamola in **# == Extensions**.

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=30}
~~~~~~~~
  # acts_as_taggable_on required -----------------------------------------------
  acts_as_taggable # Alias for acts_as_taggable_on :tags
  #-----------------------------------------------------------------------------
~~~~~~~~



## Verifichiamo l'utilizzo

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> post = Post.last
 => #<Post id: 8, title:...

> post.tags
 => #<ActiveRecord::Associations::CollectionProxy []>

> post.tag_list.add("good post", "decent post", "too long")
 => ["good post", "decent post", "too long"] 

> post.save
 => true

> post.reload
 => #<Post id: 8, title:

> post.tags
 => #<ActiveRecord::Associations::CollectionProxy [#<ActsAsTaggableOn::Tag id: 3, name: "too long", taggings_count: 1>, #<ActsAsTaggableOn::Tag id: 2, name: "decent post", taggings_count: 1>, #<ActsAsTaggableOn::Tag id: 1, name: "good post", taggings_count: 1>]>
 
> post.tag_list.remove("decent post", "good post")
 => ["too long"]

> post.save
 => true

> post.reload
 => #<Post id: 8, title:

> post.tags
 => #<ActiveRecord::Associations::CollectionProxy [#<ActsAsTaggableOn::Tag id: 3, name: "too long", taggings_count: 1>]>
~~~~~~~~




## Aggiorniamo il controller

Aggiorniamo i posts nella parte Authors perché vogliamo inserire, modificare ed eliminare i tags. Inseriamo la variabile **:tag_list** nella withe-list dei params. 

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=84}
~~~~~~~~
      # Never trust parameters from the scary internet, only allow the white list through.
      def post_params
        params.require(:post).permit(:title, :body, :description, :author_id, :image, :incipit, :sharing_image, :sharing_description, :tag_list)
      end
~~~~~~~~




## Aggiorniamo il views 

inseriamo il campo tags

{title=".../app/views/authors/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=56}
~~~~~~~~
          <li class="list-group-item">
            <div class="field">
              <%= form.label :tag_list %><!-- separati da virgola -->
              <%= form.text_area :tag_list, id: :tag_list, class: "form-control" %>
            </div>
          </li>
~~~~~~~~


verifichiamo 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails s -b $IP -p $PORT
~~~~~~~~

Entriamo nell'ultimo post e verifichiamo che c'è la parola **too long** cancelliamo e sostituiamo con le tre parole separate da virgola: **Biciclette, Tape VHS, gomma da masticare** e clickiamo update.

entriamo in console e verifichiamo che ha funzionato

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c
> post = Post.last
 => #<Post id: 8, title:...

> post.tags
 => #<ActiveRecord::Associations::CollectionProxy [#<ActsAsTaggableOn::Tag id: 6, name: "gomma da masticare", taggings_count: 1>, #<ActsAsTaggableOn::Tag id: 5, name: "Tape VHS", taggings_count: 1>, #<ActsAsTaggableOn::Tag id: 4, name: "Biciclette", taggings_count: 1>]> 
~~~~~~~~




## Implementiamo views posts/index

Aggiungiamo i vari tags come links e passiamo il parametro params[:tag] con il nome del tag. Questo ci servirà in seguito per fare un filtro degli articoli in funzione del tag. 

{title=".../app/views/posts/_posts_index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=32}
~~~~~~~~
  				<div class="entry-content">
  				  <%#= post.tags.map(&:name).join(', ') %>
  				  <% post.tags.each do |tag| %>
  				    <%= link_to tag.name, posts_path(tag: tag.name) %>
  				  <% end %>
  				</div>    
~~~~~~~~




## Aggiorniamo il controller per filtrare i tags

usiamo il params[:tag] per filtrare gli articoli in funzione del tag. Nello specifico usiamo la funzione della gemma installata **tagged_with(params[:tag])**

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  def index
    if params[:tag].present?
      @posts = Post.most_recent.published.tagged_with(params[:tag])
    else
      @posts = Post.most_recent.published
    end
  end
~~~~~~~~


verifichiamo 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails s -b $IP -p $PORT
~~~~~~~~




## salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add acts-as-taggable-on gem"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku tp:master
$ heroku run rails db:migrate
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge tp
$ git branch -d tp
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~

