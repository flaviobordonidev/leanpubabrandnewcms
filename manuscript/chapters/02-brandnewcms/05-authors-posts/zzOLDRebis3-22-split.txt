# La doppia vita dei posts

In questo capitolo pieghiamo leggermente le convenzioni Rails e sfruttiamo la sua "magia"...

Per poter implementare la parte di sicurezza e disegnare un ambiente per i posts che è accessibile a tutti ed un ambiente di gestione che è accessibile solo agli autori dei rispettivi posts duplichiamo la cartella posts e la mettiamo all'interno di due cartelle principali che chiameremo **blog** ed **authors**

* dentro **blog** i posts saranno accessibili da tutti ma in sola visualizzazione.
* dentro **authors** i posts saranno accessibili solo dai rispettivi autori che potranno anche crearne di nuovi, editarli ed eliminarli. In pratica una "dashboard" di gestione dei posts.

Questa separazione si poteva fare anche senza duplicare la cartella posts e creare una sovrastruttura ma in questo modo si ha più flessibilità per crescere e diversificare gli ambienti. Inoltre è più netta e facile definire l'ambiente protetto da "devise" a cui possono accedere solo gli autori (ossia gli utenti loggati). Inoltre quest'approccio è utile dal punto di vista didattico perché ci mostra alcuni aspetti del funzionamento di Rails e ci forza a capire un po' di più su come lavora il file **routes.rb**




## Incapsuliamo posts dentro blog

creiamo la cartella **authors** e la cartella **blog**. Spostiamo la cartella **posts** dentro la cartella **blog** e mettiamone una copia anche dentro la cartella **authors**.

* .../app/views/posts/            ->  .../app/views/blog/posts/
* .../app/views/posts/            ->  .../app/views/authors/posts/

Adesso abbiamo ovviamente errore nella nostra app. Risolviamo la cosa:
Correggiamo il file di routes. Spostiamo il **resources :posts** dentro lo **scope module: 'blog'** 

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  scope module: 'blog' do
    resources :posts
  end
~~~~~~~~

Correggiamo il controller 

* .../app/controllers/posts_controller.rb            ->  .../app/controllers/blog/posts_controller.rb 

aggiungiamo il namespacing "blog" al controller. 

{title=".../controllers/blog/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Blog
  # qui dentro copiamo tutto il codice di posts_controller.rb
end
~~~~~~~~

Questo namespacing produce Blog::PostsController che useremo nella nostra applicazione.


verifichiamo 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
~~~~~~~~

https://rebisworld3-flaviobordonidev.c9users.io/posts  --> Funziona :)
https://rebisworld3-flaviobordonidev.c9users.io  --> Errore :(

Correggiamo la chiamata di root nel routes file

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  root 'blog/posts#index'
~~~~~~~~




## Continuiamo con la duplicazione

Adesso continuiamo con la nostra duplicazione di posts e mettiamo tutte le azioni restful dentro il namespacing authors su routes, lasciando dentro lo scope blog solo le chiamate di visualizzazione (index e show)


{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  namespace :author do
    resources :posts
  end

  scope module: 'blog' do
    get 'posts' => 'posts#index'
    get 'posts/:id' => 'posts#show'
  end
~~~~~~~~

Il codice **get 'posts/:id' => 'posts#show'** fa si che se metto nel mio URL

* https://posts/foobar

nell'azione show del controller posts_controller viene passato il parametro **:id** con il valore "foobar"

* params[:id] == "foobar"

Altro esempio. Se usavamo **get 'posts/:favorite_cat' => 'posts#show'** nell'azione show di posts_contrelle avevamo

* https://posts/foobar --> params[:favorite_cat] == "foobar"




## Posts new edit e destroy

abbiamo sistemato la parte blog ed al momento non funzionano le azioni new, edit e destroy perché vogliamo che queste siano gestite solo dagli autori. Per mettere l'istradamento new su scope module: 'blog' avremmo dovuto inserire la riga

  get "posts/new" => 'posts#new'
  
Ma non vogliamo questo!

Prima di continuare vediamo la differenza tra **scope module:** e **namespace**

il namespace si aspetta tutto il percorso nell'url
lo scope nasconde il percorso reale e lascia solo la parte finale nell'url

Nel nostro caso per author avremo nell'URL
.../authors/posts
.../authors/posts/1
.../authors/posts/new
.../authors/posts/1/edit

invece per blog avremo nell'URL
.../posts
.../posts/1


Creiamo la nuova cartella **authors** in cui inserire una copia di **posts_controller**

{title=".../controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  # qui dentro copiamo tutto il codice di posts_controller.rb
end
~~~~~~~~

nel blog/posts_controller cancelliamo tutte le azioni che non usiamo

{title=".../controllers/blog/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Blog
  class PostsController < ApplicationController

    # GET /posts
    # GET /posts.json
    def index
      #@posts = Post.all
      @posts = Post.most_recent
    end
  
    # GET /posts/1
    # GET /posts/1.json
    def show
        @post = Post.friendly.find(params[:id])
    end
  end
end
~~~~~~~~

adesso puliamo nel views/blog/posts tutti i files che non usiamo. Cancelliamo

*  views/blog/posts/_form.html.erb
*  views/blog/posts/edit.html.erb
*  views/blog/posts/new.html.erb



## Differenziamo la parte authors

Iniziamo a differenziare la parte degli autori modificando views/authors/posts/index e rendendola più simile ad una dashboard.

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<% provide(:page_title, 'All Posts') %>

<!DOCTYPE html>
<html dir="ltr" lang="en-US">

<%= render 'head' %>

<body class="stretched">

	<!-- Document Wrapper
	============================================= -->
	<div id="wrapper" class="clearfix">

		<section id="content">

			<div class="content-wrap">

				<div class="container clearfix">

					<!-- Post Content
					============================================= -->
					<div class="postcontent nobottommargin clearfix">

						<%= render 'posts', posts: @posts %>


						<!-- Pagination
						============================================= -->
						<ul class="pager nomargin">
							<li class="previous"><a href="#">&larr; Older</a></li>
							<li class="next"><a href="#">Newer &rarr;</a></li>
						</ul><!-- .pager end -->

					</div><!-- .postcontent end -->
				</div>
			</div>

		</section><!-- #content end -->

		<%= render 'footer' %>

	</div><!-- #wrapper end -->

	<!-- Go To Top
	============================================= -->
	<div id="gotoTop" class="icon-angle-up"></div>

	<!-- External JavaScripts
	============================================= -->
	<!-- <script type="text/javascript" src="js/jquery.js"></script> -->
	<!-- <script type="text/javascript" src="js/plugins.js"></script> -->
	<%= javascript_include_tag 'jquery', 'data-turbolinks-track' => true %>
	<%= javascript_include_tag 'plugins', 'data-turbolinks-track' => true %>

	<!-- Footer Scripts
	============================================= -->
	<!-- <script type="text/javascript" src="js/functions.js"></script> -->
	<%= javascript_include_tag 'functions', 'data-turbolinks-track' => true %>

</body>
</html>
~~~~~~~~


{title=".../app/views/authors/posts/_posts.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<p id="notice"><%= notice %></p>

<h1>Posts</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Body</th>
      <th>Description</th>
      <th>Slug</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @posts.each do |post| %>
      <tr>
        <td><%= link_to post.title, authors_post_path(post) %></td>
        <td><%= post.body %></td>
        <td><%= post.description %></td>
        <td><%= post.slug %></td>
        <td><%= link_to 'Show', authors_post_path(post) %></td>
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>
~~~~~~~~

Da evidenziare i links che nel percorso hanno anche "authors"

{title=".../app/views/authors/posts/_posts.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
        <td><%= link_to 'Show', authors_post_path(post) %></td>
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~

Correggiamo in authors/posts_controller il redirect dell'azione destroy

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
        format.html { redirect_to authors_posts_url, notice: 'Post was successfully destroyed.' }
~~~~~~~~

Non funziona. Perché?
Purtroppo è dovuto al fatto di come gestiamo bootstrap. Infatti per riflettere lo standard restful l'invio del comando di destroy dovrebbe essere inviato con un put di :delete come richiesta HTML. Questa richiesta non è ancora gestita dalla maggior parte dei browser ed allora si è creato un workaround che converte il link in una chiamata post con l'invio del comando di destroy. Questo workaround è stato implementato nel pacchetto bootstrap specifico di Rails. Quindi funziona solo se si installa bootstrap utilizzando la gemma.
Noi abbiamo caricato direttamente bootstrap dal template e quindi non abbiamo questo workaround.

Come possiamo fare?
l'alternativa è quella di non usare il link ma di usare un button che attiva la chiamata post.

{title=".../app/views/authors/posts/_posts.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
        <td><%= button_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~

Solo che queso ha bisogno di un po' di stylesheet ed inoltre non funziona il confirm! Cancella senza chiederti se sei sicuro. Quindi prevede più codice per evitare cancellazioni indesiderate.

Più avanti risolveremo installando bootstrap attraverso la gemma e togliendo il pacchetto bootstrap.js preso dal template.



## Altro punto che ci eravamo dimenticati il partial _form

nel submit del form dobbiamo specificare l'url a cui deve andare con post/patch perché il percorso non è più in convenzione rails. Siccome sono due percorsi diversi uno per edit e l'altro per new usiamo una variabile che chiamiamo **url** e passiamo il valore dal render di edit e dal render di new  

{title=".../app/views/authors/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: post, local: true, url: url) do |form| %>
~~~~~~~~

{title=".../app/views/authors/posts/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', post: @post, url: authors_post_url(@post) %>
~~~~~~~~

{title=".../app/views/authors/posts/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=3}
~~~~~~~~
<%= render 'form', post: @post, url: authors_posts_url %>
~~~~~~~~




















salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add scaffold Post and implement friendly_id gem"
~~~~~~~~


