# La Dashboard

siamo all'inizio del video [How to build a blog with Rails 5 and Bootstrap 4 - Part 3](https://www.youtube.com/watch?v=fPpJsAU4qIY)

Prepariamo la nostra dashboard. Incapsuliamo una copia di posts dentro il modulo **Authors** in modo da avere tutta la parte di gestione degli articoli protetta da login con devise e con un suo specifico layout tutto dentro uno stesso modulo.
Si poteva anche gestire il tutto senza usare il modulo ma questa gestione mi piace di più perché è chiaro cosa appartiene alla gestione fatta sulla dashboard ed ho delle ridondanze che posso personalizzare (ad esempio un doppio controller per la stessa tabella posts).


CMSbase
Inserire bootstrap via gem 
Rails g scaffold Post 
Creare il modulo “authors” che ingloba una copia di posts. Questo modulo:
permette di isolare un layout tutto per lui senza doverlo fare dal controller posts_controller per ogni singola azione.
Permette di proteggere tutto il namespace ...authors… con devise senza doverlo fare sul controller posts_controller per ogni singola azione.
Il view authors/posts/show si può eliminare ed usare solo posts/show.
Nella routes si può specificare nella resources posts 
Permette di avere un index dedicato alla dashboard che ha tutti i posts dell’autore compresi quelli non pubblicati. Utile ma si può fare anche senza creare il modulo. Però così è più pulito perché ho anche un controller dedicato. 
Togliere edit, new e delete dal posts normale. Sarà lui a prendersi il template. Nel nostro caso il template Canvas. Ma questo lo metteremo solo alla fine.
Invece su authors/posts usiamo un template stile dashboard. Usiamo quello personalizzato fatto dal tizio di cui stiamo seguendo il tutorial.




## Apriamo il branch "Modulo Authors per la Dashboard"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b mad
~~~~~~~~




## La doppia vita dei posts

Pieghiamo leggermente le convenzioni Rails e sfruttiamo la sua "magia"...

Per poter implementare la parte di sicurezza e disegnare un ambiente per i posts che è accessibile a tutti ed un ambiente di gestione che è accessibile solo agli autori dei rispettivi posts duplichiamo la cartella posts e la mettiamo all'interno di una cartella principale che chiameremo **authors**

* la cartella **posts** nella posizione standard sarà accessibile da tutti ma lasciamo in sola visualizzazione.
* la cartella **posts** duplicata dentro **authors** sarà accessibile solo dai rispettivi autori che potranno gestire i loro articoli (posts); crearne di nuovi, editarli ed eliminarli. In pratica una "dashboard" di gestione dei posts.

Questa separazione si poteva fare anche senza duplicare la cartella posts e creare una sovrastruttura ma in questo modo si ha più flessibilità per crescere e diversificare gli ambienti. Inoltre è più netta e facile definire l'ambiente protetto da "devise" a cui possono accedere solo gli autori (ossia gli utenti loggati). Inoltre quest'approccio è utile dal punto di vista didattico perché ci mostra alcuni aspetti del funzionamento di Rails e ci forza a capire un po' di più su come lavora il file **routes.rb**

Incapsuliamo posts dentro **authors**
creiamo la cartella **authors** e mettiamoci dentro una copia della cartella **posts**.

* .../app/views/posts/            ->  .../app/views/authors/posts/ (copia/incolla di "posts/")




## instradiamo authors/posts

Impostiamo l'instradamento attraverso il namespace authors

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  namespace :authors do
    resources :posts
  end

  resources :posts
~~~~~~~~

Ho doppio resources :posts solo che uno è dentro il namespace :authors questo vuol dire che sono attivi tutti i sette instradamenti restful su due percorsi:

* https://mydomain/posts/...
* https://mydomain/auhots/posts/...

Verifichiamo i vari percorsi/instradamenti (paths) sul terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes -T ?????????????????????????????????????????????????????????????????????????????????????????????
~~~~~~~~




## Creiamo il controller

Creiamo authors_controller.rb 

{title=".../app/controllers/authors_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AuthorsController < ApplicationController
end
~~~~~~~~

creiamo la cartella **authors** che sarà il nostro modulo su cui inglobare i **posts**.
Dentro la cartella creiamo il file posts_controller.rb 
Siccome questo file è dentro la sottocartella **authors** dobbiamo indicargli che si trova là e questo lo facciamo indicandogli che è in un "module"

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < ApplicationController
  end
end
~~~~~~~~

questo fa si che le chiamate siano del tipo Auhtors::PostsController

adesso invece di ereditare da ApplicationController diciamogli di ereditare da AuthorsController

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  class PostsController < AuthorsController
~~~~~~~~

Ora l'incapsulamento è pronto. possiamo copiarci tutto il codice del posts_controller.rb già esistente


{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < AuthorsController
  .
  .
  .
  end
end
~~~~~~~~

[tutto il codice: authors/posts_controller.rb](#brandnewcms-05code-app-controllers-authors-posts_controller.rb)




## puliamo le routes

vogliamo che l'utente normale possa visualizzare tutti i posts pubblicati sia l'elenco che i singoli.
vogliamo che l'autore abbia un elenco di "lavoro" dei suoi posts, possa crearne di nuovi, editarli ed eliminarli. Per la visualizzazioe del singolo posts usa lo stesso di tutti gli altri (così non devo caricare un nuovo tema anche dentro authors/posts/show)

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  resources :posts, :only => [:index, :show]

  namespace :authors do
    resources :posts, :except => [:show]
  end
~~~~~~~~




## puliamo i controllers posts

Iniziamo a differenziare lo standard posts da quello incapsulato authors/posts e nello specifico lasciamo ai controllers solo le azioni che sono effettivamente usate.

posts         -> :index, :show
authors/posts -> :index, :edit, :update, :new, :create, :destroy

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class PostsController < ApplicationController

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
  end

  # GET /posts/1
  # GET /posts/1.json
  def show
    @post = Post.friendly.find(params[:id])
  end
end
~~~~~~~~


{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < AuthorsController
    before_action :set_post, only: [:show, :edit, :update, :destroy]
  
    # GET /posts
    # GET /posts.json
    def index
      @posts = Post.all
    end

    # GET /posts/new
    def new
      @post = Post.new
    end
  
    # GET /posts/1/edit
    def edit
    end
  
    # POST /posts
    # POST /posts.json
    def create
      @post = Post.new(post_params)
  
      respond_to do |format|
        if @post.save
          format.html { redirect_to @post, notice: 'Post was successfully created.' }
          format.json { render :show, status: :created, location: @post }
        else
          format.html { render :new }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # PATCH/PUT /posts/1
    # PATCH/PUT /posts/1.json
    def update
      respond_to do |format|
        if @post.update(post_params)
          format.html { redirect_to @post, notice: 'Post was successfully updated.' }
          format.json { render :show, status: :ok, location: @post }
        else
          format.html { render :edit }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # DELETE /posts/1
    # DELETE /posts/1.json
    def destroy
      @post.destroy
      respond_to do |format|
        format.html { redirect_to posts_url, notice: 'Post was successfully destroyed.' }
        format.json { head :no_content }
      end
    end
  
    private
      # Use callbacks to share common setup or constraints between actions.
      def set_post
        @post = Post.friendly.find(params[:id])
      end
  
      # Never trust parameters from the scary internet, only allow the white list through.
      def post_params
        params.require(:post).permit(:title, :body, :description)
      end
  end
end
~~~~~~~~




## puliamo le views posts

eliminiamo:

* .../app/views/posts/_form.html.erb
* .../app/views/posts/edit.html.erb
* .../app/views/posts/_new.html.erb

* .../app/views/authors/posts/show.html.erb




## Personalizziamo il layout per authos

per mantenere un layout personalizzato è sufficiente chiamarlo con lo stesso nome del controller. Duplichiamo layouts/application.html.erb e rinominiamo la copia in layouts/auhtors.html.erb

* .../app/views/layouts/application.html.erb    ->  .../app/views/layouts/authors.html.erb (copia/incolla e rinomina)

{title=".../app/views/layouts/authors.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=4}
~~~~~~~~
<!DOCTYPE html>
<html>
  <head>
    <title><%= yield(:page_title) %> | Brandnewcms</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <%= render 'layouts/navbar' %>
    <p>Solo per autori</p>
    <div class="container <%= controller_name %> <%= action_name %>">
      <%= yield %>
    </div>  
  </body>
</html>
~~~~~~~~

Al momento aggiungiamo il semplice **<p>Solo per autori</p>** per differenziarlo.




## Aggiorniamo la barra di navigazione (navbar)

aggiungiamo una di voce alla nostra navbar per i posts degli autori

{title=".../app/views/layouts/_navbar.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=18}
~~~~~~~~
      <li class="nav-item <%= yield(:authors_active) %>">
        <%= link_to 'My posts', authors_posts_path, class: "nav-link" %>
      </li>
~~~~~~~~

ed i relativi **provide**, per lo **yield** nei rispettivi views

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~

{title=".../app/views/authors/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~

{title=".../app/views/authors/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~




## Aggiorniamo authors/posts/index

aggiorniamo i vari links_to

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=24}
~~~~~~~~
        <td><%= link_to 'Show', authors_post_path(post) %></td>
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=34}
~~~~~~~~
<%= link_to 'New Post', new_authors_post_path %>
~~~~~~~~




## Iniziamo a personalizzare la dashboard

rendiamo auhtors/posts/index più simile ad un ambiente di "lavoro" per i posts dell'autore

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<% provide(:page_title, "All posts") %>
<% provide(:authors_active, "active") %>

<div class="row">
  <table class="table table-striped">
    <thead>
      <tr>
        <th>Title</th>
        <th>Body</th>
        <th>Description</th>
        <th colspan="3"></th>
      </tr>
    </thead>
  
    <tbody>
      <% @posts.each do |post| %>
        <tr>
          <td><%= post.title %></td>
          <td><%= post.body %></td>
          <td><%= post.description %></td>
          <td><%= link_to 'Show', authors_post_path(post) %></td>
          <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
          <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
        </tr>
      <% end %>
    </tbody>
  </table>
</div>


<%= link_to 'New Post', new_authors_post_path %>
<p id="notice"><%= notice %></p>
~~~~~~~~

rendiamo il titolo del post linkabile

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=18}
~~~~~~~~
          <td><%= link_to post.title, authors_post_path(post) %></td>
~~~~~~~~




## Correggiamo i reinstradamenti delle azioni di modifica dei posts

Nel nostro controller authors/posts_controller correggiamo i reinstradamenti delle azioni update, create e destroy

in realtà mi va bene che dopo la creazione e l'aggiornamento vada sul posts standard. l'unica modifica è per il destroy

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=61}
~~~~~~~~
        format.html { redirect_to authors_posts_url, notice: 'Post was successfully destroyed.' }
~~~~~~~~




## Correggiamo il sumbit del form

dopo il submit del nostro form dobbiamo arrivare all'azione create o update sul controller auhtors/posts_controller.
Per far questo dobbiamo passargli l'url comprensivo del namespace. Siccome l'url è diverso a seconda se sono su edit o su new, gli passiamo una variabile con il valore settato nelle rispettive pagine.

{title=".../app/views/authors/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: post, local: true, url: url) do |form| %>
~~~~~~~~


{title=".../app/views/authors/posts/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=6}
~~~~~~~~
<%= render 'form', post: @post, url: authors_post_url(@post) %>
~~~~~~~~

{title=".../app/views/authors/posts/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= render 'form', post: @post, url: authors_posts_url %>
~~~~~~~~





Per questo capitolo è tutto



salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Incapsule a copy of posts in the module author"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku mad:master
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge mad
$ git branch -d mad
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~


