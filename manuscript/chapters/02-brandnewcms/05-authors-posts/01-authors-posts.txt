# La Dashboard

Prepariamo la nostra dashboard. Incapsuliamo una copia di posts dentro il modulo **Authors** in modo da avere tutta la parte di gestione degli articoli protetta da login con devise e con un suo specifico layout tutto dentro uno stesso modulo.
Si poteva anche gestire il tutto senza usare il modulo ma questa gestione mi piace di più perché è chiaro cosa appartiene alla gestione fatta sulla dashboard ed ho delle ridondanze che posso personalizzare (ad esempio un doppio controller per la stessa tabella posts).

Creare il modulo “authors” che ingloba/incapsula una copia di posts.
  permette di isolare un layout tutto per lui senza doverlo fare dal controller posts_controller per ogni singola azione.
  Permette di proteggere tutto il namespace ...authors… con devise senza doverlo fare sul controller posts_controller per ogni singola azione.

Il view authors/posts/show si può eliminare ed usare solo posts/show.
Nella routes si può specificare nella resources posts 
Permette di avere un index dedicato alla dashboard che ha tutti i posts dell’autore compresi quelli non pubblicati. Utile ma si può fare anche senza creare il modulo. Però così è più pulito perché ho anche un controller dedicato. 
Togliere edit, new e delete dal posts normale. Sarà lui a prendersi il template. Nel nostro caso il template Canvas. Ma questo lo metteremo solo alla fine.
Invece su authors/posts usiamo un template stile dashboard. Usiamo quello personalizzato fatto dal tizio di cui stiamo seguendo il tutorial.



Risorse web:
siamo all'inizio del video [How to build a blog with Rails 5 and Bootstrap 4 - Part 3](https://www.youtube.com/watch?v=fPpJsAU4qIY)

* [Rails Authorization With Pundit - parte da zero ed installa anche devise ed usa anche spec tests](https://www.youtube.com/watch?v=qruGD_8ry7k)




## Apriamo il branch "Modulo Authors per la Dashboard"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b mad
~~~~~~~~




## La doppia vita dei posts

Pieghiamo leggermente le convenzioni Rails e sfruttiamo la sua "magia"...

Per poter implementare la parte di sicurezza e disegnare un ambiente per i posts che è accessibile a tutti ed un ambiente di gestione che è accessibile solo agli autori dei rispettivi posts duplichiamo la cartella posts e la mettiamo all'interno di una cartella principale che chiameremo **authors**

* la cartella **posts** nella posizione standard sarà accessibile da tutti ma lasciamo la sola visualizzazione.
* la cartella **posts** duplicata dentro **authors** sarà accessibile solo dai rispettivi autori che potranno gestire i loro articoli (posts); crearne di nuovi, editarli ed eliminarli. In pratica una "dashboard" di gestione dei posts.

Questa separazione si poteva fare anche senza duplicare la cartella posts e creare una sovrastruttura ma in questo modo si ha più flessibilità per crescere e diversificare gli ambienti. Inoltre è più netta e facile definire l'ambiente protetto da "devise" a cui possono accedere solo gli autori (ossia gli utenti loggati). Inoltre quest'approccio è utile dal punto di vista didattico perché ci mostra alcuni aspetti del funzionamento di Rails e ci forza a capire un po' di più su come lavora il file **routes.rb**

Incapsuliamo posts dentro **authors**
creiamo la cartella **authors** e mettiamoci dentro una copia della cartella **posts**.

* .../app/views/posts/            ->  .../app/views/authors/posts/ (copia/incolla di "posts/")




## instradiamo authors/posts

Impostiamo l'instradamento attraverso il namespace authors

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  namespace :authors do
    resources :posts
  end

  resources :posts
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01a)

Ho doppio resources :posts solo che uno è dentro il namespace :authors questo vuol dire che sono attivi tutti i sette instradamenti restful su due percorsi:

* https://mydomain/posts/...
* https://mydomain/authors/posts/...

Verifichiamo i vari percorsi/instradamenti (paths) sul terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes
$ rails routes | egrep "posts"
~~~~~~~~




## Creiamo la cartella authors

creiamo la cartella **authors** che sarà il nostro modulo su cui inglobare i **posts**.
Dentro la cartella copiamo il file posts_controller.rb 
Siccome questo file è dentro la sottocartella **authors** dobbiamo indicargli che si trova là e questo lo facciamo indicandogli che è in un "module"
Per far questo racchiudiamo tutto dentro il **module Authors**.

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < ApplicationController
  .
  .
  .
  end
end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01b)

questo fa si che le chiamate siano del tipo Auhtors::PostsController

un'alternativa, usata anche da devise, è quella di dichiarare che è in un modulo/sottocartella direttamente nella definizione della classe.

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class Authors::PostsController < ApplicationController
.
.
.
end
~~~~~~~~

Le due definizioni sono identiche.




## puliamo le routes

vogliamo che l'utente normale possa visualizzare tutti i posts pubblicati sia l'elenco che i singoli.
vogliamo che l'autore abbia un elenco di "lavoro" dei suoi posts, possa crearne di nuovi, editarli ed eliminarli. 
Da notare che ho due "index" perché quello dell'autore ha una struttura ed un layout diverso da quello del lettore (reader), ossia dell'utente non loggato.
Per la visualizzazioe del singolo posts invece usiamo solo quello del lettore così l'autore vedrà il suo articolo con lo stesso layout/theme del lettore.

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  resources :posts, :only => [:index, :show]

  namespace :authors do
    resources :posts, :except => [:show]
  end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01c-routes)

Verifichiamo i vari percorsi/instradamenti (paths) sul terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes
$ rails routes | egrep "posts"
~~~~~~~~




## puliamo i controllers posts

Iniziamo a differenziare lo standard posts (quello per il lettore) da quello incapsulato authors/posts (quello per l'autore). 
Nello specifico lasciamo ai controllers solo le azioni che sono effettivamente usate.

posts         -> :index, :show
authors/posts -> :index, :edit, :update, :new, :create, :destroy

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class PostsController < ApplicationController

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
  end

  # GET /posts/1
  # GET /posts/1.json
  def show
    @post = Post.friendly.find(params[:id])
  end
end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01d-controllers-posts_controller.rb)

Puliamo il codice:
Non ha più senso avere il codice separato nel metodo private "set_post" chiamato da "before_action" e quindi lo riporto dentro l'azione show.
Inoltre non modificando i records non ci serve il metodo private "post_params"

Implementiamo nel codice:
L'alenco di tutti gli authors/posts è filtrato per l'autore che si è loggato.
Non vede tutti gli articoli ma solo i suoi articoli sia pubblicati che non.
(L'amministratore invece vedrà tutti gli articoli sia pubblicati che non.)


{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < AuthorsController
  
    before_action :set_post, only: [:edit, :update, :destroy]
  
    # GET /posts
    # GET /posts.json
    def index
      #@posts = Post.all
      @posts = current_author.posts unless current_author.admin?
      @posts = Post.all if current_author.admin?
    end

    # GET /posts/new
    def new
      @post = Post.new
    end
  
    # GET /posts/1/edit
    def edit
    end
  
    # POST /posts
    # POST /posts.json
    def create
      @post = Post.new(post_params)
  
      respond_to do |format|
        if @post.save
          format.html { redirect_to @post, notice: 'Post was successfully created.' }
          format.json { render :show, status: :created, location: @post }
        else
          format.html { render :new }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # PATCH/PUT /posts/1
    # PATCH/PUT /posts/1.json
    def update
      respond_to do |format|
        if @post.update(post_params)
          format.html { redirect_to @post, notice: 'Post was successfully updated.' }
          format.json { render :show, status: :ok, location: @post }
        else
          format.html { render :edit }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # DELETE /posts/1
    # DELETE /posts/1.json
    def destroy
      @post.destroy
      respond_to do |format|
        format.html { redirect_to posts_url, notice: 'Post was successfully destroyed.' }
        format.json { head :no_content }
      end
    end
  
    private
      # Use callbacks to share common setup or constraints between actions.
      def set_post
        @post = Post.friendly.find(params[:id])
      end
  
      # Never trust parameters from the scary internet, only allow the white list through.
      def post_params
        params.require(:post).permit(:title, :body, :description)
      end
  end
end
~~~~~~~~

qui abbiamo tolto l'azione "show" e la sua chiamata in "before_action"




## puliamo le views posts

eliminiamo:

* .../app/views/posts/_form.html.erb
* .../app/views/posts/edit.html.erb
* .../app/views/posts/_new.html.erb

* .../app/views/authors/posts/show.html.erb




## Aggiorniamo posts/index

togliamo i links_to non più usati da ".../app/views/posts/index.html.erb"

~~~~~~~~
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
        .
        .
        .
        <%= link_to 'New Post', new_post_path %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01e)




## Aggiorniamo posts/show

togliamo il link_to non più usato da ".../app/views/posts/show.html.erb"

~~~~~~~~
<%= link_to 'Edit', edit_post_path(@post) %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01f)




## Aggiorniamo authors/posts/index

aggiorniamo i vari links_to

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=24}
~~~~~~~~
        <td><%= link_to 'Show', authors_post_path(post) %></td>
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=34}
~~~~~~~~
<%= link_to 'New Post', new_authors_post_path %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01g)

le views edit, new e _form le aggiorniamo più avanti




salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Incapsule a copy of posts in the module author"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku mad:master
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge mad
$ git branch -d mad
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
