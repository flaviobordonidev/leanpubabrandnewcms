# La Dashboard

Prepariamo la nostra dashboard. Incapsuliamo una copia di posts dentro il modulo **Authors** in modo da avere tutta la parte di gestione degli articoli protetta da login con devise e con un suo specifico layout tutto dentro uno stesso modulo.
Si poteva anche gestire il tutto senza usare il modulo ma questa gestione mi piace di più perché è chiaro cosa appartiene alla gestione fatta sulla dashboard ed ho delle ridondanze che posso personalizzare (ad esempio un doppio controller per la stessa tabella posts).

Creare il modulo “authors” che ingloba/incapsula una copia di posts.
  permette di isolare un layout tutto per lui senza doverlo fare dal controller posts_controller per ogni singola azione.
  Permette di proteggere tutto il namespace ...authors… con devise senza doverlo fare sul controller posts_controller per ogni singola azione.

Il view authors/posts/show si può eliminare ed usare solo posts/show.
Nella routes si può specificare nella resources posts 
Permette di avere un index dedicato alla dashboard che ha tutti i posts dell’autore compresi quelli non pubblicati. Utile ma si può fare anche senza creare il modulo. Però così è più pulito perché ho anche un controller dedicato. 
Togliere edit, new e delete dal posts normale. Sarà lui a prendersi il template. Nel nostro caso il template Canvas. Ma questo lo metteremo solo alla fine.
Invece su authors/posts usiamo un template stile dashboard. Usiamo quello personalizzato fatto dal tizio di cui stiamo seguendo il tutorial.

Risorse web:
siamo all'inizio del video [How to build a blog with Rails 5 and Bootstrap 4 - Part 3](https://www.youtube.com/watch?v=fPpJsAU4qIY)

* [Rails Authorization With Pundit - parte da zero ed installa anche devise ed usa anche spec tests](https://www.youtube.com/watch?v=qruGD_8ry7k)



## Apriamo il branch "Modulo Authors per la Dashboard"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b mad
~~~~~~~~




## La doppia vita dei posts

Pieghiamo leggermente le convenzioni Rails e sfruttiamo la sua "magia"...

Per poter implementare la parte di sicurezza e disegnare un ambiente per i posts che è accessibile a tutti ed un ambiente di gestione che è accessibile solo agli autori dei rispettivi posts duplichiamo la cartella posts e la mettiamo all'interno di una cartella principale che chiameremo **authors**

* la cartella **posts** nella posizione standard sarà accessibile da tutti ma lasciamo la sola visualizzazione.
* la cartella **posts** duplicata dentro **authors** sarà accessibile solo dai rispettivi autori che potranno gestire i loro articoli (posts); crearne di nuovi, editarli ed eliminarli. In pratica una "dashboard" di gestione dei posts.

Questa separazione si poteva fare anche senza duplicare la cartella posts e creare una sovrastruttura ma in questo modo si ha più flessibilità per crescere e diversificare gli ambienti. Inoltre è più netta e facile definire l'ambiente protetto da "devise" a cui possono accedere solo gli autori (ossia gli utenti loggati). Inoltre quest'approccio è utile dal punto di vista didattico perché ci mostra alcuni aspetti del funzionamento di Rails e ci forza a capire un po' di più su come lavora il file **routes.rb**

Incapsuliamo posts dentro **authors**
creiamo la cartella **authors** e mettiamoci dentro una copia della cartella **posts**.

* .../app/views/posts/            ->  .../app/views/authors/posts/ (copia/incolla di "posts/")




## instradiamo authors/posts

Impostiamo l'instradamento attraverso il namespace authors

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=7}
~~~~~~~~
  namespace :authors do
    resources :posts
  end

  resources :posts
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01a)

Ho doppio resources :posts solo che uno è dentro il namespace :authors questo vuol dire che sono attivi tutti i sette instradamenti restful su due percorsi:

* https://mydomain/posts/...
* https://mydomain/authors/posts/...

Verifichiamo i vari percorsi/instradamenti (paths) sul terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes
$ rails routes | egrep "posts"
~~~~~~~~




## Creiamo il controller

################################################################################
DA ELIMINARE
Creiamo authors_controller.rb 

{title=".../app/controllers/authors_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AuthorsController < ApplicationController
end
~~~~~~~~
################################################################################

creiamo la cartella **authors** che sarà il nostro modulo su cui inglobare i **posts**.
Dentro la cartella copiamp il file posts_controller.rb 
Siccome questo file è dentro la sottocartella **authors** dobbiamo indicargli che si trova là e questo lo facciamo indicandogli che è in un "module"
Per far questo racchiudiamo tutto dentro il **module Authors**.

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < ApplicationController
  .
  .
  .
  end
end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01b)

questo fa si che le chiamate siano del tipo Auhtors::PostsController


################################################################################
DA ELIMINARE
adesso invece di ereditare da ApplicationController diciamogli di ereditare da AuthorsController

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < AuthorsController
~~~~~~~~
################################################################################





## puliamo le routes

vogliamo che l'utente normale possa visualizzare tutti i posts pubblicati sia l'elenco che i singoli.
vogliamo che l'autore abbia un elenco di "lavoro" dei suoi posts, possa crearne di nuovi, editarli ed eliminarli. Per la visualizzazioe del singolo posts usa lo stesso di tutti gli altri (così non devo caricare un nuovo tema anche dentro authors/posts/show)

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=4}
~~~~~~~~
  resources :posts, :only => [:index, :show]

  namespace :authors do
    resources :posts, :except => [:show]
  end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01c)

Verifichiamo i vari percorsi/instradamenti (paths) sul terminale

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails routes
$ rails routes | egrep "posts"
~~~~~~~~




## puliamo i controllers posts

Iniziamo a differenziare lo standard posts da quello incapsulato authors/posts e nello specifico lasciamo ai controllers solo le azioni che sono effettivamente usate.

posts         -> :index, :show
authors/posts -> :index, :edit, :update, :new, :create, :destroy

{title=".../app/controllers/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class PostsController < ApplicationController

  # GET /posts
  # GET /posts.json
  def index
    @posts = Post.all
  end

  # GET /posts/1
  # GET /posts/1.json
  def show
    @post = Post.friendly.find(params[:id])
  end
end
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01d)

Non ha più senso avere il codice separato nel metodo private "set_post" chiamato da "before_action" e quindi lo riporto dentro l'azione show.
Inoltre non modificando i records non ci serve il metodo private "post_params"


{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
module Authors
  class PostsController < AuthorsController
  
    before_action :set_post, only: [:edit, :update, :destroy]
  
    # GET /posts
    # GET /posts.json
    def index
      @posts = Post.all
    end

    # GET /posts/new
    def new
      @post = Post.new
    end
  
    # GET /posts/1/edit
    def edit
    end
  
    # POST /posts
    # POST /posts.json
    def create
      @post = Post.new(post_params)
  
      respond_to do |format|
        if @post.save
          format.html { redirect_to @post, notice: 'Post was successfully created.' }
          format.json { render :show, status: :created, location: @post }
        else
          format.html { render :new }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # PATCH/PUT /posts/1
    # PATCH/PUT /posts/1.json
    def update
      respond_to do |format|
        if @post.update(post_params)
          format.html { redirect_to @post, notice: 'Post was successfully updated.' }
          format.json { render :show, status: :ok, location: @post }
        else
          format.html { render :edit }
          format.json { render json: @post.errors, status: :unprocessable_entity }
        end
      end
    end
  
    # DELETE /posts/1
    # DELETE /posts/1.json
    def destroy
      @post.destroy
      respond_to do |format|
        format.html { redirect_to posts_url, notice: 'Post was successfully destroyed.' }
        format.json { head :no_content }
      end
    end
  
    private
      # Use callbacks to share common setup or constraints between actions.
      def set_post
        @post = Post.friendly.find(params[:id])
      end
  
      # Never trust parameters from the scary internet, only allow the white list through.
      def post_params
        params.require(:post).permit(:title, :body, :description)
      end
  end
end
~~~~~~~~

qui abbiamo tolto l'azione "show" e la sua chiamata in "before_action"




## puliamo le views posts

eliminiamo:

* .../app/views/posts/_form.html.erb
* .../app/views/posts/edit.html.erb
* .../app/views/posts/_new.html.erb

* .../app/views/authors/posts/show.html.erb




## Aggiorniamo posts/index

togliamo i links_to non più usati da ".../app/views/posts/index.html.erb"

~~~~~~~~
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
        .
        .
        .
        <%= link_to 'New Post', new_post_path %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01e)




## Aggiorniamo posts/show

togliamo il link_to non più usato da ".../app/views/posts/show.html.erb"

~~~~~~~~
<%= link_to 'Edit', edit_post_path(@post) %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01f)




## Aggiorniamo authors/posts/index

aggiorniamo i vari links_to

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=24}
~~~~~~~~
        <td><%= link_to 'Show', authors_post_path(post) %></td>
        <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
        <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
~~~~~~~~

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=34}
~~~~~~~~
<%= link_to 'New Post', new_authors_post_path %>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01g)

le views edit, new e _form le aggiorniamo più avanti




## Creiamo un layout personalizzato per la dashboard

Duplichiamo il layouts/application e rinominiamo la copia layouts/dashboard

* .../app/views/layouts/application.html.erb    ->  .../app/views/layouts/dashboard.html.erb (copia, incolla e rinomina)

Inoltre aggiungiamo il container per bootstrap ed un semplice **<h2>Solo per autori</h2>** per differenziarlo.

{title=".../app/views/layouts/dashboard.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=14}
~~~~~~~~
    <div class="container">
      <p class="notice"><%= notice %></p>
      <p class="alert"><%= alert %></p>
      <h2>Solo per Autori</h2>
      <%= yield %>
    </div>
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01h)





## Assegnamo il layout dashboard alle pagine degli autori

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
  layout 'dashboard'
~~~~~~~~

[tutto il codice](#brandnewcms-authors_posts-01i)




## Iniziamo a personalizzare la dashboard

rendiamo auhtors/posts/index più simile ad un ambiente di "lavoro" per i posts dell'autore

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%# == Meta_data ============================================================ %>

<% provide(:page_title, "All posts") %>
<% provide(:authors_active, "active") %>

<%# == Meta_data - end ====================================================== %>

<div class="row">
  <table class="table table-striped">
    <thead>
      <tr>
        <th>Title</th>
        <th>Incipit</th>
        <th colspan="3"></th>
      </tr>
    </thead>
  
    <tbody>
      <% @posts.each do |post| %>
        <tr>
          <td><%= post.title %></td>
          <td><%= post.incipit %></td>
          <td><%= link_to 'Show', authors_post_path(post) %></td>
          <td><%= link_to 'Edit', edit_authors_post_path(post) %></td>
          <td><%= link_to 'Destroy', authors_post_path(post), method: :delete, data: { confirm: 'Are you sure?' } %></td>
        </tr>
      <% end %>
    </tbody>
  </table>
</div>


<%= link_to 'New Post', new_authors_post_path %>
<p id="notice"><%= notice %></p>
~~~~~~~~

abbiamo inserito "authors_active" per evidenziare la nuova voce della navbar che inseriamo nel prossimo paragrafo

volendo potremmo rendere il titolo del post un link che va su show

{title=".../app/views/authors/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=18}
~~~~~~~~
          <td><%= link_to post.title, authors_post_path(post) %></td>
~~~~~~~~




## Aggiorniamo la barra di navigazione (navbar)

aggiungiamo una voce alla nostra navbar per i posts degli autori (index, edit e new)

{title=".../app/views/layouts/_navbar.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=18}
~~~~~~~~
      <li class="nav-item <%= yield(:authors_active) %>">
        <%= link_to 'Area Modifiche', authors_posts_path, class: "nav-link" %>
      </li>
~~~~~~~~

ed i relativi **provide**, per lo **yield** nei rispettivi views

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~

{title=".../app/views/authors/posts/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~

{title=".../app/views/authors/posts/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=2}
~~~~~~~~
<% provide(:authors_active, "active") %>
~~~~~~~~





## Correggiamo i reinstradamenti delle azioni di modifica dei posts

Nel nostro controller authors/posts_controller correggiamo i reinstradamenti delle azioni update, create e destroy

in realtà mi va bene che dopo la creazione e l'aggiornamento vada sul posts standard. l'unica modifica è per il destroy

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=61}
~~~~~~~~
        format.html { redirect_to authors_posts_url, notice: 'Post was successfully destroyed.' }
~~~~~~~~




## Correggiamo il sumbit del form

Effettuato il submit del nostro form dobbiamo arrivare all'azione create o update sul controller auhtors/posts_controller.
Per convenzione rails dopo il submit siamo reinstradati sull'azione create o update del controller posts_controller.
Dobbiamo quindi specificare, effettuato il submit, l'url a cui deve andare con post/patch perché il percorso non è più in convenzione rails.
Per far questo dobbiamo passargli l'url comprensivo del namespace.
Siccome sono due percorsi diversi uno per edit e l'altro per new usiamo una variabile che chiamiamo **url** e passiamo il valore dal render di edit e dal render di new.
Detto in altro modo:
Siccome l'url è diverso a seconda se sono su edit o su new, gli passiamo una variabile con il valore settato nelle rispettive pagine. Questa variabile la chiamiamo "url".


{title=".../app/views/authors/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= form_with(model: post, local: true, url: url) do |form| %>
~~~~~~~~


{title=".../app/views/authors/posts/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=6}
~~~~~~~~
<%= render 'form', post: @post, url: authors_post_url(@post) %>
~~~~~~~~

{title=".../app/views/authors/posts/new.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~
<%= render 'form', post: @post, url: authors_posts_url %>
~~~~~~~~




Per questo capitolo è tutto



salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Incapsule a copy of posts in the module author"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku mad:master
~~~~~~~~




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge mad
$ git branch -d mad
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~


