# Autentichiamo ed Autorizziamo in funzione del ruolo

Implementiamo l'autorizzazione permettendo solo agli autori e all'amministratore di fare le modifiche.

Risorse web

* [Rails Authorization With Pundit - parte da zero ed installa anche devise ed usa anche spec tests](https://www.youtube.com/watch?v=qruGD_8ry7k)



## Definiamo le autenticazioni

Le autenticazioni con devise sono implementate in fase di creazione degli utenti. 
Quindi i seguenti utenti che abbiamo già  già creato hanno tutti il processo di autenticazione con devise:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

> User.all

#<ActiveRecord::Relation [
#<User id: 4, name: "C", email: "carl@test.abc", created_at: "2018-06-20 10:34:13", updated_at: "2018-06-20 10:34:13">, 
#<User id: 3, name: "B", email: "bob@test.abc", created_at: "2018-06-20 10:34:00", updated_at: "2018-06-20 10:34:00">, 
#<User id: 2, name: "A", email: "ann@test.abc", created_at: "2018-06-20 10:33:45", updated_at: "2018-08-08 12:01:43">, 
#<User id: 1, name: "Flavio Bordoni", email: "flavio@test.abc", created_at: "2018-06-18 12:32:53", updated_at: "2018-08-08 13:35:54">]> 
~~~~~~~~

Ognuno di questi utenti viene autenticato inserendo la sua user e password nella pagina di login. In altre parole è accettato ad entrare.

Una volta dentro sarà autorizzato o meno a seconda dei ruoli che gli vengono assegnati.




## Assegnamo dei ruoli da console

Con rolify assegnamo dei ruoli ai vari utenti

Diamo il ruolo di amministratore all'utente con id=1 per tutta l'applicazione 
Diamo il ruolo di moderatore all'utente con id=2 per la sola tabella **posts** per tutti gli articoli
Diamo il ruolo di autore all'utente con id=3 per la sola tabella **posts** e solo per gli articoli creati da lui
Lasciamo senza ruoli l'utente con id=4

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails c

  # Definiamo un ruolo globale
> u1 = User.find(1)
> u1.add_role :admin

> u1.has_role? :admin
=> true
> u1.has_role? :admin, Post
=> true
> u1.has_role? :admin, Post.first
=> true
> u1.has_role? :admin, Post.find(5)
=> true
> u1.has_role? :admin, Post.last
=> true

  # Definiamo un ruolo per una classe
> u2 = User.find(2)
> u2.add_role :moderator, Post

> u2.has_role? :moderator
=> false
> u2.has_role? :moderator, Post
=> true
> u2.has_role? :moderator, Post.first
=> true
> u2.has_role? :moderator, Post.find(5)
=> true
> u2.has_role? :moderator, Post.last
=> true

  # Definiamo un ruolo per una istanza
> u3 = User.find(3)
> u3.add_role :author, Post.find(1)
> u3.add_role :author, Post.find(4)

> u3.has_role? :author
=> false
> u3.has_role? :author, Post
=> false
> u3.has_role? :author, Post.find(1)
=> true
> u3.has_role? :author, Post.find(2)
=> false
> u3.has_role? :author, Post.find(5)
=> false
~~~~~~~~

Il primo utente ha il ruolo :admin per tutto (a livello globale).
Il secondo utente ha il ruolo :moderator per tutti gli articoli (a livello di classe Post)
Il terzo utente ha il ruolo di :author solo per il primo ed il quarto articolo (a livello di istanza). Glia bbiamo assegnato questi articoli come se li avesse creati lui.
Il quarto utente non ha nessun ruolo




## Implementiamo il ruolo di autore per i nuovi articoli

Una volta che un utente ha fatto login (e quindi è autenticato tramite devise) ha accesso alla dashboard ma non può editare nessun articolo.
Può però crearne di nuovi. Una volta creati gli assegnamo il ruolo di autore per quegli articoli e quindi quelli sarà autorizzato a modificarli.

In pratica questo viene usato assegnando il ruolo tutte le volte che l'autore crea un nuovo articolo. Quindi inserisco il ruolo durante l'azione "create".

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=11}
~~~~~~~~
  def create
    @post = Post.new(post_params)
      if @post.save
        current_user.add_role :author, @post
        redirect_to @post, notice: 'Post was successfully created.'
      else
        render :new
      end
  end
~~~~~~~~




## Implementiamo le autorizzazioni

Con pundit assegnamo le autorizzazioni ai vari ruoli.

Per la tabella posts
  Il ruolo di amministratore è autorizzato a fare tutto
  Il ruolo di moderatore è autorizzato a cancellare qualsiasi articolo. Non può editarli.
  Il ruolo di autore è autorizzato ad editare e cancellare solo i suoi articoli (quelli creati da lui).
  Un utente loggato che non ha ruoli può solo creare un nuovo articolo.
  Se un utente non è loggato può solo visualizzare gli articoli




## Creiamo la policy

La convenzione pundit per le policies è che abbiano lo stesso nome del "model" con il suffisso "_policy" quindi nel nostro caso abbiamo "post_policy.rb".
Non ci dobbiamo preoccupare che il controller per la modifica degli articoli è incapsulata nel modulo "authors" perché pundit per le policies si riferisce al "model".
Ci occuperemo nel prossimo paragrafo di coinvolgere il controller che ci interessa implementando le autorizzazioni.

{title=".../app/policies/post_policy.rb", lang=ruby, line-numbers=on, starting-line-number=11}
~~~~~~~~
  class PostPolicy < ApplicationPolicy
  
    def index?
      true
    end
  
    def show?
      true
    end
    
    def create?
      @user.present?
    end
    
    def update?
      if @user.present?
        @user.has_role? :author or @user.has_role? :admin
      else
        false
      end
    end
  
    def destroy?
      if @user.present?
        @user.has_role? :author, Post.find(1) or @user.has_role? :moderator, Post or @user.has_role? :admin
        u2.has_role? :author, Post or u2.has_role? :moderator, Post or  u2.has_role? :admin
      else
        false
      end
    end
    
    class Scope < Scope
      def resolve
        scope.all
      end
    end
  end
~~~~~~~~


******
    def create?
      #@user.present? ? @user.has_role?(:admin) : false
      if @user.present?
        @user.has_role? :admin
      else
        false
      end
    end
*******



################################################################################


PUNDIT SENZA ROLIFY CON RELAZIONE UNO-A-MOLTI USER->POSTS


At this point, you need to establish a relationship between your Article and User model.

You do so by generating a new migration.

1
rails generate migration add_user_id_to_articles user:references
Next, migrate your database by running the command:

1
rake db:migrate
Open the User model and add the line that seals the relationship.

1
2
3
4
#app/models/user.rb
 
...
  has_many :articles
Your Article model should have this.

1
2
3
4
#app/models/article.rb
 
...
  belongs_to :user
Now you need to update your ArticlesController so it is in sync with what you have done so far.



################################################################################



You want to add a standard error message that shows whenever a non-authorized user tries to access a restricted page. To do so, add the following to your ApplicationController.

#app/controllers/application_controller.rb
~~~~~~~~
 
...
  rescue_from Pundit::NotAuthorizedError, with: :user_not_authorized
 
  private
 
    def user_not_authorized
      flash[:warning] = "You are not authorized to perform this action."
      redirect_to(request.referrer || root_path)
    end
~~~~~~~~

This code simply renders a basic text that tells the user s/he is not authorized to perform the action.




################################################################################





Hide the Delete Button from View

If a user can’t delete a wiki, there is no point in even rendering the “Delete” button. Great news, Pundit provides a special helper method (in the form of a conditional) that you can add to your views:
<% if policy(@wiki).destroy? %>
    <%= link_to "Delete", @wiki, method: :delete, class: 'btn btn-danger' %>
<% end %>



- if policy(Company).new?
  = link_to 'Nova empresa', new_company_path
  
  
  
- if policy(company).update?
  td = link_to 'Editar', edit_company_path(company)