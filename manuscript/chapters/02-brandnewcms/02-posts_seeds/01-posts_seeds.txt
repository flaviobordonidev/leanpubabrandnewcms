# Gli articoli del blog

Creiamo il cuore del nostro CMS (Content Management System) ossia gli articoli del nostro blog.




## Apriamo il branch "Posts Seeds"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b ps
~~~~~~~~




## Creiamo la struttura per gli articoli (posts)

title       	: titolo dell'articolo. Quello che ha una bella copy.
incipit       : il testo che è sull'indice. L'inizio di un articolo che spesso è anche troncato ad hoc.
content       : il testo principale del post
type 		      : image, video su youtube, video su vimeo, quote, podcast, ... (il tipo di post/articolo; se ha immagine o video o altro). Di tipo ENUM
image         : l'eventuale foto
video         : l'eventuale video (al posto della foto)
seocontent    : il testo che appare sui motori di ricerca (spesso coincide con l'incipit)
tags          : le parole più ricercate / le parole chiave
date_chosen   : data che assegnamo al post. Utile per gestire pubblicazioni automatiche o allineare le date con le campagne di email marketing.
user_id		    : utente che ha scritto il post
comment_id	  : commenti (in realtà non serve perché usiamo disqus o facebook)


il "Read more" in italiano è tradotto come "Leggi tutto" o "Continua a leggere" o  "Approfondisci". A volte non si mette solo il simbolo di continua "[...]" senza link "Leggi tutto" e si lascia solo il link sul titolo.

Iniziamo con una parte della struttura e poi via via implementiamo il resto.

Usiamo lo Scaffold che mi imposta già l'applicazione in stile restful con le ultime convenzioni Rails.
Lo scaffold crea su routes la voce resources, crea il modulo, il migration, e tutte le views un controller con le 7 azioni in stile restful:
index, show, new, edit, create, update e destroy. 

I> ATTENZIONE: con "rails generate scaffold ..." -> uso il SINGOLARE

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold Post title:string incipit:text content:text type:integer video_youtube:string video_vimeo:string seocontent:text date_chosen:date user:references
~~~~~~~~

* La cosa bella di **user_references** è che, oltre a creare la colonna **user_id:integer**, ci aggiunge anche l'indice in tabella e ci predispone la relazione uno-a-molti.
* il campo :image non lo uso sulla tabella perchè con activestorage viene definito a livello di Models
* Date.today

questo crea il migrate:

{title=".../db/migrate/xxx_create_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class CreatePosts < ActiveRecord::Migration[5.2]
  def change
    create_table :posts do |t|
      t.string :title
      t.text :incipit
      t.text :content
      .
      .
      .

      t.timestamps
    end
  end
end
~~~~~~~~

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




## Sistemiamo le routes

Lo scaffold già ci ha creato il **resources :posts** diamo solo una sistemata alle righe per una questione di ordine e non di funzionalità

{title=".../config/routes.rb", lang=ruby, line-numbers=on, starting-line-number=10}
~~~~~~~~
  resources :posts
~~~~~~~~




## Completiamo la relazione uno-a-molti con user

nella sezione "# == Relationships" --> "## one-to-many"

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=18}
~~~~~~~~
  belongs_to :user
~~~~~~~~

{title=".../app/models/user.rb", lang=ruby, line-numbers=on, starting-line-number=18}
~~~~~~~~
  has_many :posts
~~~~~~~~




## Didattico - Aggiunta successiva di colonne

Se per fare una prova avessimo implementato lo scaffold con solo le colonne "title", "incipit" e l'indice esterno di users "user_id" (user:references) possiamo aggiungere le restanti con questo migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration AddContentTypeVideoSeoDateToPost content:text type:integer video_youtube:string video_vimeo:string seocontent:text date_chosen:date
~~~~~~~~

questo crea il migrate:

{title=".../db/migrate/xxx_add_content_type_video_seo_date_to_post.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddContentTypeVideoSeoDateToPost < ActiveRecord::Migration[5.2]
  def change
    add_column :posts, :content, :text
    add_column :posts, :type, :integer
    add_column :posts, :video_youtube, :string
    add_column :posts, :video_vimeo, :string
    add_column :posts, :seocontent, :text
    add_column :posts, :date_chosen, :date
  end
end
~~~~~~~~

Effettuiamo il migrate del database per creare la tabella sul database

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

### In questo caso avremmo dovuto anche aggiornare il controller

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=70}
~~~~~~~~
    # Never trust parameters from the scary internet, only allow the white list through.
    def post_params
      params.require(:post).permit(:title, :incipit, :content, :type, :video_youtube, :video_vimeo, :seocontent, :date_chosen, :user_id)
    end
~~~~~~~~





## Verifichiamo se funziona tutto

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails s -b $IP -p $PORT
~~~~~~~~

Potrebbe essere necessaria una modifica per il new perché non associa l'user in automatico
lo risolvo passando l'user nel create "@post.user = current_user" ma questo è poco elegante. Meglio "@post = current_user.posts.new(post_params)"

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
    def create
      @post = Post.new(post_params)
      @post.user = current_user
~~~~~~~~

Non possiamo agire a livello di azione "new" perché non abbiamo la colonna "id" abilitata nella white list e non abbiamo il form.hidden nella view _form.
E' molto più semplice passare la chiave esterna "user_id" direttamente nell'azione create.
Volendo si può comunque uniformare anche l'azione new:

{title=".../app/controllers/authors/posts_controller.rb", lang=ruby, line-numbers=on, starting-line-number=5}
~~~~~~~~
    def new
      #@post = Post.new
      @post = current_user.posts.new
~~~~~~~~

comunque se non implementiamo il relativo campo nel _form e nella whitelist del controller avere "@post = current_user.posts.new" non cambia nulla.
Diventerà invece interessante più avanti nei prossimi capitoli quando implementeremo che l'amministratore può cambiare l'autore dell'articolo.
In quel caso passeremo l'id dell'autore scelto nel submit del form.




## Salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add scaffold Post"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku ps:master
$ heroku run rails db:migrate
~~~~~~~~




## Popoliamo manualmente

inseriamo quattro articoli (posts) e mettiamo il contenuto usando https://hipsum.co/ che è simile a Lorem ipsum ma più divertente.




## Aggiungiamo la colonna con l'email dell'autore che si è loggato in authors/posts/index

Una volta loggato visualizzo anche il nome dell'autore nell'elenco

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=15}
~~~~~~~~
        <th>Published</th>
~~~~~~~~

{title=".../app/views/authors/posts/index.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=25}
~~~~~~~~
          <td><%= post.user.email %></td>
~~~~~~~~

[tutto il codice](#brandnewcms-posts_seeds-01a-views-authors-posts-index.html.erb)






## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge ps
$ git branch -d ps
~~~~~~~~


## Facciamo un backup su Github

Dal nostro branch master di Git facciamo un backup di tutta l'applicazione sulla repository remota Github.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
