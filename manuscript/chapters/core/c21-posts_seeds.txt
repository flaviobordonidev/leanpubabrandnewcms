# Posts seeds




## Analisi del Post per creare la parte dinamica

adesso è ora di attivare l'MVC di rails. Analizza il post per vedere che dati archiviare sul database ed isola i seguenti riferimenti:

post_id
entry-image <-- ci pensa Refile
entry-title
entry-meta-calendar <-- ci pensa il timestamp
entry-meta-user <-- ci pensa Devise
entry-meta-tag or folder (vedi railscasts sulla gestione dei tag separati da uno spazio...)
entry-meta-comments (numero di commenti. questo va implementato usando la gemma....)
entry-meta-kind (indica il tipo di post: video, immagine, audio, ...)
entry-content-read-more
entry-content


Crea l'entità "Post" usando lo Scaffold che gli imposta già l'applicazione in stile restful con le ultime convenzioni Rails.
Lo scaffold crea su routes la voce resources, crea il modulo, il migration, e tutte le views un controller con le 7 azioni in stile restful:

index, show, new, edit, create, update e destroy. 

I> ATTENZIONE: con "rails generate scaffold ..." -> uso il SINGOLARE

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g scaffold Post image_id:string title:string content_short:string content_first:text content_blockquote:text content_second:text
~~~~~~~~

I> per Refile mettimao il campi image_id:string e sulla nostra tabella e ci accertiamo che non ci sia sulla tabella un campo "image" altrimenti ho dei conflitti con l'attachment :image messo sul model. 

questo crea il migrate:

[codice: posts db 01](#code-blogs-db-01)

{title="db/migrate/xxx_create_blogs.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string, :image_id
      t.string, :title
      t.string, :content_short
      t.text, :content_first
      t.text, :content_blockquote
      t.text, :content_second

      t.timestamps null: false
    end
  end
end
~~~~~~~~

Effettuiamo il migrate del database per creare la tabella "blogs" sul database


{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rake db:migrate
~~~~~~~~

Adesso andiamo su localhost:3000/blogs e creiamo tre nuovi blogs (al momento non possiamo ancora mettere le immagini)




## Heroku ed il production db

Facciamo un git su questa prima pietra-miliare e pubblichiamo il tutto su heroku.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "pietra miliare"
$ git push heroku mock_post:master
~~~~~~~~


se provo https://guarded-retreat-51105.herokuapp.com/blogs mi arriva un messaggio di errore. Questo perché non ho il database aggiornato. Per aggiornare il database di produzione dobbiamo fare

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ heroku run rake db:migrate
~~~~~~~~

una volta migrato il database https://guarded-retreat-51105.herokuapp.com/blogs funziona ma ovviamente non ha i dati che sono stati messi sul database di sviluppo.
Fla si diverte emozionato a mettere i primi dati di prova...
