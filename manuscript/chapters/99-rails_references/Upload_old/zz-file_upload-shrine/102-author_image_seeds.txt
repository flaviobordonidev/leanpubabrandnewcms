# Inseriamo l'immagine dell'autore

Anche se gestiamo i dati tramite il controller accounts, per non doverci sovrapporre alla gestione "author" che abbiamo affidato a devise, l'aggiunta della colonna author_image è fatta nella tabella users.




## Apriamo il branch "Author Image"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b ai
~~~~~~~~




## Aggiungiamo la colonna "image" alla tabella "users"

Per l'immagine, siccome uso Shrine per l'upload, chiamo la colonna **image_data** usando la convenzione di Shrine. (vedi brandnewcms 11-gem-shrine-file_upload)
Non la chiamiamo **author_image_data** perché siamo già dentro la tabella **users** e non abbiamo altre colonne **image** da cui doverci differenziare.

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration AddImageToUsers image_data:text
~~~~~~~~

questo crea il migrate:

{title=".../db/migrate/xxx_add_image_to_users.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddImageTousers < ActiveRecord::Migration[5.1]
  def change
    add_column :users, :image_data, :text
  end
end
~~~~~~~~

eseguiamo il migrate 

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~




## Aggiorniamo il model

nel model Author leghiamo shrine alla colonna image_data

{title=".../app/models/author.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  include ImageUploader[:image]
~~~~~~~~

la voce :image viene associata automaticamente da shrine alla colonna :image_data

I> Informazione!
I>
I> ImageUploader lo abbiamo già creato per le colonne :image e :sharing_image del model post. Usiamo lo stesso file .../app/models/image_uploader.rb

I> Informazione!
I>
I> l'immagine sarà già caricata su AWS S3 perché abbiamo attivato il tutto nel capitolo brandnewcms/12-aws_s3.txt




## Aggiorniamo le views

{title=".../app/views/users/accounts/edit.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=11}
~~~~~~~~
            <li class="list-group-item">
              <div class="field">
                <%= f.label :image %>
                <% if current_author.image.present? %>
                  <%= image_tag current_author.image_url, class: "card-img-top" %>
                <% end %>
                <%#= f.hidden_field :image, value: f.object.cached_image_data %>
                <%= f.file_field :image, class: "form-control" %>  
              </div>
            </li>
~~~~~~~~

usiamo **f.object** al posto della variabile d'istanza **@sharing_image** così non siamo costretti a definire la variabile sul controller e la nostra view è più "self-contained" e quindi riutilizzabile anche su pagine multiple. 

Per personalizzare la label è meglio usare i18n in config/locales/en.yml e rinominare le labeles del model Post

title=".../config/locales/en.yml", lang=yaml, line-numbers=on, starting-line-number=1}
~~~~~~~~
helpers:
    label:
      post:
        sharing_image: sharing image 476x249 px
~~~~~~~~

così possiamo lasciare sul view **<%= form.label :sharing_image %>** senza dover forzare nel codice (hardcode) la lable 'sharing image 476x249 px'




## Aggiorniamo il mass-assignment del controller

{title=".../app/controllers/controller_posts.rb", lang=ruby, line-numbers=on, starting-line-number=18}
~~~~~~~~
      # Never trust parameters from the scary internet, only allow the white list through.
      def author_info_params
        params.require(:author).permit(:image, :name, :email, :bio)
      end
~~~~~~~~




## Aggiorniamo la pagina show

{title=".../app/views/posts/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=1}
~~~~~~~~

  	<meta property="og:image" content="<%= @post.image_url %>" />

    <meta name="twitter:image:src" content="<%= @post.image_url %>"/>

~~~~~~~~


vediamo se funziona

$ sudo service postgresql start
$ rails s -b $IP -p $PORT




## Rendiamo pubblica l'immagine

Funziona tutto ma l'immagine è visibile solo se si passano i parametri di accesso ad AWS S3. Invece per condividerla sui social è meglio renderla pubblica.
Per farlo si eseguono i seguenti due passaggi:
1. sul nostro codice usiamo il parametro "public: true" di shrine in modo da dichiarare che l'url è pubblico e non servono tutte le credenziali di accesso passate nell'URL

{title=".../app/views/posts/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=12}
~~~~~~~~
  	<meta property="og:image" content="<%= @post.image_url(public: true) %>" /><!-- image 476x249 px (es: http://www.webisworld.com/images/events/varie/share9fb.jpg) -->
~~~~~~~~

{title=".../app/views/posts/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=21}
~~~~~~~~
    <meta name="twitter:image:src" content="<%= @post.image_url(public: true) %>"/><!-- image 476x249 px (es: http://www.webisworld.com/images/events/varie/share9fb.jpg) -->
~~~~~~~~

2. sul sito AWS S3 

* Effetttuiamo il login sul sito di amazon web service https://console.aws.amazon.com. Cerchiamo il service - storage - S3.
* selezioniamo il nostro bucket "brandnewcms_dev"
* mettiamo flag sulla cartelle "store". Andiamo su "More" -> "Make Public" (questo rende reiterativamente pubblici (in lettura) tutti i file presenti nella cartella ma i nuovi file uploadati con shrine saranno privati.

Adesso le immagini sono publiche e quindi le possiamo vedere senza credenziali di accesso.


## Verifichiamo la parte Facebook

vediamo se funziona

$ sudo service postgresql start
$ rails s -b $IP -p $PORT

apriamo il browser su https://developers.facebook.com/
e passiamo l'url della nostra pagina posts/show -> https://brandnewcms-flaviobordonidev.c9users.io/posts/la-bella-lavanderina


I> Attenzione!
I>
I> Ho la sensazione che funziona anche con le immagini private ma non ricevi un errore chiaro nel caso ci siano problemi. Devo fare qualche altro test, la cosa sembrava funzionare ma avevo un errore che ho scoperto essere immagine troppo piccola (almeno 200x200) quando l'ho resa pubblica.

Riferimenti web:

* https://codyeatworld.com/2017/04/18/rails-uploading-images-confidently-with-shrine-rb/
* http://shrinerb.com/rdoc/classes/Shrine/Storage/S3.html
* https://twin.github.io/better-file-uploads-with-shrine-direct-uploads/



## Rendiamo pubblici i files durante l'upload

# The S3 storage plugin handles uploads to Amazon S3 service, using the aws-sdk gem.
Shrine.storages = {
  # With Shrine both temporary (:cache) and permanent (:store) storage are first-class citizens and fully configurable, so you can also have files cached on S3.
  cache: Shrine::Storage::S3.new(prefix: 'cache', upload_options: { acl: 'public-read' }, **s3_options),
  store: Shrine::Storage::S3.new(prefix: 'store', upload_options: { acl: 'public-read' }, **s3_options)
}

Se non ho **upload_options** specificato il comportamento di default è ** acl: 'private' **.
questo:
  store: Shrine::Storage::S3.new(prefix: "store", **s3_options),
  
è uguale a questo:
  store: Shrine::Storage::S3.new(prefix: "store", upload_options: { acl: 'private' }, **s3_options),




salviamo su git

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git add -A
$ git commit -m "Add social sharing - facebook and twitter"
~~~~~~~~




## Pubblichiamo su Heroku

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push heroku sft:master
$ heroku run rails db:migrate
~~~~~~~~




## Popoliamo manualmente

inseriamo quattro articoli (posts) e mettiamo il contenuto usando https://hipsum.co/ che è simile a Lorem ipsum ma più divertente.




## Chiudiamo il branch

se abbiamo finito le modifiche e va tutto bene:

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout master
$ git merge sft
$ git branch -d sft
~~~~~~~~


aggiorniamo github

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git push origin master
~~~~~~~~
