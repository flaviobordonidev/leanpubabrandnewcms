# Installiamo Shrine per fare upload delle immagini

Aggiungiamo la gemma **shrine** alla nostra applicazione per implementare l'upload di files e immagini.

Upload files e immagini
Usare Shrine per l’upload
Usare Trix per il testo formattato
Implementare Shrine dentro Trix 
(How to use Trix and Shrine for WYSIWYG Editing with Drag-and-Drop Image Uploading)[http://headway.io/blog/how-to-use-trix-and-shrine-for-wysiwyg-editing-with-drag-and-drop-image-uploading/]

Risorse web:

* https://gorails.com/episodes/file-uploading-with-shrine
* https://code.tutsplus.com/tutorials/uploading-files-with-rails-and-shrine--cms-27596
* https://codyeatworld.com/2017/04/18/rails-uploading-images-confidently-with-shrine-rb/

* https://github.com/shrinerb/shrine 
* http://shrinerb.com/



## Apriamo il branch "Gem Shrine Install"

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ git checkout -b gsi
~~~~~~~~





## installiamo la gemma shrine

I> verifichiamo [l'ultima versione della gemma](https://rubygems.org/gems/shrine)
I>
I> facciamo riferimento al [tutorial github della gemma](https://github.com/shrinerb/shrine)

{title=".../Gemfile", lang=ruby, line-numbers=on, starting-line-number=48}
~~~~~~~~
# Shrine is a flexible and modular file upload 
gem 'shrine', '~> 2.10', '>= 2.10.1'
~~~~~~~~

[tutto il codice: Gemfile](#brandnewcms-10code-gemfile.rb)

Eseguiamo l'installazione della gemma con bundle

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ bundle install
~~~~~~~~




## Creiamo il file di inizializzazione

creiamo il nuovo file **shrine.rb** dentro config/inizializers e copiamoci il testo preso dal [tutorial github della gemma](https://github.com/shrinerb/shrine) ma adattandolo a Rails.
Quindi mettiamo :activerecord invece di :sequel e togliamo l'ultima riga che è per applicazioni non Rails.

{title=".../config/initializers/shrine.rb", lang=ruby, line-numbers=on, starting-line-number=48}
~~~~~~~~
require "shrine"
require "shrine/storage/file_system"

Shrine.storages = {
  cache: Shrine::Storage::FileSystem.new("public", prefix: "uploads/cache"), # temporary
  store: Shrine::Storage::FileSystem.new("public", prefix: "uploads/store"), # permanent
}

Shrine.plugin :activerecord
Shrine.plugin :cached_attachment_data # for forms
~~~~~~~~

cash  : posto dove è temporaneamente caricato il file prima che venga salvato nel record del database 
store : posto dove è permanentemente archiviato il file
questi due possono essere il filesystem locale oppure un archivio remoto come AWS S3 (Amazon Web Services). Heroku non permette di usare il FileSystem quindi prima di andare in produzione implementiamo AWS S3.






## Aggiungiamo la colonna per le immagini alla nostra tabella posts

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ rails g migration AddImageDataToPosts image_data:text
~~~~~~~~

questo crea il migrate

{title=".../db/migrate/xxx_add_image_data_to_posts.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class AddImageDataToPosts < ActiveRecord::Migration[5.1]
  def change
    add_column :posts, :image_data, :text
  end
end
~~~~~~~~

effettuiamo il migrate

{title="terminal", lang=bash, line-numbers=off}
~~~~~~~~
$ sudo service postgresql start
$ rails db:migrate
~~~~~~~~

nel model Post mettiamo una validazione per vedere come lavora **Shrine.plugin :cached_attachment_data** in caso di errore di validazione nel submit di un form.

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  validates :title, presence: true
~~~~~~~~




## Creiamo l'uploader per shrine

siccome in sviluppo (development) stiamo usando il filesystem per archiviare i files (Shrine::Storage::FileSystem.new) creiamo una cartella **uploader** direttamente dentro la cartella **app** della nostra applicazione.

.../app/uploaders/

Dentro questa nuova cartella possiamo mettere il file di uploader per le immagini

{title=".../app/uploaders/image_uploader.rb", lang=ruby, line-numbers=on, starting-line-number=1}
~~~~~~~~
class ImageUploader < Shrine
  # plugins and uploading logic
end
~~~~~~~~




## Leghiamo shrine alla colonna image_data della tabella posts

per colleare shrine alla colonna image_data usiamo il model Post.

{title=".../app/models/post.rb", lang=ruby, line-numbers=on, starting-line-number=3}
~~~~~~~~
  include ImageUploader[:image]
~~~~~~~~

al posto di **include ImageUploader[:image]** si poteva usare
  # include ImageUploader::Attachment.new(:image) # adds an `image` virtual attribute
oppure
  # include ImageUploader.new(:image)
  
la voce :image viene associata automaticamente da shrine alla colonna :image_data




## Aggiorniamo le views

prendiamo le righe di codice dal tutorial github di shrine

    <%= f.hidden_field :image, value: @image.cached_image_data %>
    <%= f.file_field :image %>  

e le adattiamo per Rails

{title=".../app/views/posts/_form.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=29}
~~~~~~~~
  <div class="field">
    <%= form.label :title %>
    <%= f.hidden_field :image, value: f.object.cached_image_data %>
    <%= f.file_field :image %>  
  </div>
~~~~~~~~

usiamo **f.object** al posto della variabile d'istanza **@image** così non siamo costretti a definire la variabile sul controller e la nostra view è più "self-contained" e quindi riutilizzabile anche su pagine multiple. 



## Aggiorniamo il mass-assignment del controller


{title=".../app/controllers/controller_posts.rb", lang=ruby, line-numbers=on, starting-line-number=75}
~~~~~~~~
        params.require(:post).permit(:title, :body, :description, :author_id, :image)
~~~~~~~~




## Implementiamo la pagina show

{title=".../app/views/posts/show.html.erb", lang=HTML+Mako, line-numbers=on, starting-line-number=17}
~~~~~~~~
<p>
  <% if @post.image.present? %>
    <%= image_tag @post.image_url %>
  <% end %>
</p>
~~~~~~~~


vediamo se funziona

$ sudo service postgresql start
$ rails s -b $IP -p $PORT





Heroku non accetta che venga fatto upload di files direttamente su heroku. Devo quindi attivare un servizio terzo. Nel prossimo capitolo attiviamo Amazon Web Service S3.

Attenzione. Sembra che le immagini heroku le accetta senza problemi ad esempio ho creato una nuova persona di test uploadando l'immagine flatest.png e paparclip su heroku la ha correttaemtne importata mettendola sull'url ** https://infinite-fortress-17788.herokuapp.com/system/people/images/000/000/003/original/flatest.png?1481020047 **
Ma in realtà queste vengono cancellate dopo un po' di tempo. E comunque occupano del prezioso spazio su Heroku.

Nel prossimo capitolo attiviamo Amazon Web Service S3 che è dedicato a contenere files. E' meglio lasciare su heroku solo i dati del database.
